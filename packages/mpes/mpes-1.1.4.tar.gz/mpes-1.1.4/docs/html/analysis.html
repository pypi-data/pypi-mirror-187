

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Analysis (mpes.analysis) &mdash; mpes 1.1.2 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="mpes 1.1.2 documentation" href="index.html"/>
        <link rel="next" title="Band-mapping data classes (mpes.bandstructure)" href="bandstructure.html"/>
        <link rel="prev" title="File I/O &amp; Processing (mpes.fprocessing)" href="file_io.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> mpes
          

          
          </a>

          
            
            
              <div class="version">
                1.1.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Instructions</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="I01_start.html">How to start</a></li>
<li class="toctree-l1"><a class="reference internal" href="I02_overview.html">Overview of modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="I03_usenotes.html">Usage notes</a></li>
</ul>
<p class="caption"><span class="caption-text">API documentation</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="base.html">Base classes  <code class="docutils literal notranslate"><span class="pre">(mpes.base)</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="file_io.html">File I/O &amp; Processing  <code class="docutils literal notranslate"><span class="pre">(mpes.fprocessing)</span></code></a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Analysis  <code class="docutils literal notranslate"><span class="pre">(mpes.analysis)</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="bandstructure.html">Band-mapping data classes  <code class="docutils literal notranslate"><span class="pre">(mpes.bandstructure)</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="visualization.html">Visualization  <code class="docutils literal notranslate"><span class="pre">(mpes.visualization)</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="mirrorutil.html">Local file copying  <code class="docutils literal notranslate"><span class="pre">(mpes.mirrorutil)</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="utils.html">Utility functions  <code class="docutils literal notranslate"><span class="pre">(mpes.utils)</span></code></a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">mpes</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Analysis  <code class="docutils literal notranslate"><span class="pre">(mpes.analysis)</span></code></li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/analysis.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="analysis-mpes-analysis">
<h1>Analysis  <code class="docutils literal notranslate"><span class="pre">(mpes.analysis)</span></code><a class="headerlink" href="#analysis-mpes-analysis" title="Permalink to this headline">¶</a></h1>
<p>Data analysis pipeline including background removal, segmentation and fitting</p>
<span class="target" id="module-mpes.analysis"></span><p>&#64;author: R. Patrick Xian</p>
<dl class="py class">
<dt id="mpes.analysis.BoundedArea">
<em class="property">class </em><code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">BoundedArea</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">image</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">shape</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">subimage</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.BoundedArea" title="Permalink to this definition">¶</a></dt>
<dd><p>Bounded area object from a parametric equation.</p>
<dl class="py method">
<dt id="mpes.analysis.BoundedArea.mask">
<em class="property">property </em><code class="sig-name descname">mask</code><a class="headerlink" href="#mpes.analysis.BoundedArea.mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Subimage attribute as mask</p>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.BoundedArea.setBoundary">
<code class="sig-name descname">setBoundary</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pmz</span><span class="o">=</span><span class="default_value">'linear'</span></em>, <em class="sig-param"><span class="n">boundtype</span><span class="o">=</span><span class="default_value">'&gt;'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.BoundedArea.setBoundary" title="Permalink to this definition">¶</a></dt>
<dd><p>Add bound to grid to redefine subgrid.</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>pmz: str | ‘linear’</dt><dd><p>Parametrization (pmz) of the decision boundary (‘linear’ or ‘circular’).</p>
</dd>
<dt>boundtype: str | ‘&gt;’</dt><dd><p>Bound region specification (‘&gt;’ or ‘&lt;’).</p>
</dd>
</dl>
<p><a href="#id1"><span class="problematic" id="id2">**</span></a>kwds: keyword arguments</p>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.BoundedArea.subgrid">
<em class="property">property </em><code class="sig-name descname">subgrid</code><a class="headerlink" href="#mpes.analysis.BoundedArea.subgrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Substituent pixel coordinates of the image.</p>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.BoundedArea.toMask">
<code class="sig-name descname">toMask</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">inbound</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">exbound</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.BoundedArea.toMask" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a scaled mask from existing shape.</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>inbound: float | 1</dt><dd><p>Value for the pixels within the boundary.</p>
</dd>
<dt>exbound: float | 0</dt><dd><p>Value for the pixels outside the boundary.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>modmask: 2d array</dt><dd><p>Modified mask as a 2d array.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.BoundedArea.view">
<code class="sig-name descname">view</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">origin</span><span class="o">=</span><span class="default_value">'lower'</span></em>, <em class="sig-param"><span class="n">cmap</span><span class="o">=</span><span class="default_value">'terrain_r'</span></em>, <em class="sig-param"><span class="n">axes</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.BoundedArea.view" title="Permalink to this definition">¶</a></dt>
<dd><p>Display the current mask.</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>origin: str | ‘lower’</dt><dd><p>Location of the image origin.</p>
</dd>
<dt>cmap: str | ‘terrain_r’</dt><dd><p>Color map</p>
</dd>
<dt>axes: bool | True</dt><dd><p>Axes visibility option in plot.</p>
</dd>
<dt><a href="#id3"><span class="problematic" id="id4">**</span></a>kwds: keyword arguments</dt><dd><p>Additional arguments for <code class="docutils literal notranslate"><span class="pre">matplotlib.pyplot.imshow()</span></code>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="mpes.analysis.EnergyCalibrator">
<em class="property">class </em><code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">EnergyCalibrator</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">biases</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">files</span><span class="o">=</span><span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">folder</span><span class="o">=</span><span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">file_sorting</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">traces</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">tof</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.EnergyCalibrator" title="Permalink to this definition">¶</a></dt>
<dd><p>Electron binding energy calibration workflow.</p>
<dl class="py method">
<dt id="mpes.analysis.EnergyCalibrator.addFeatures">
<code class="sig-name descname">addFeatures</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ranges</span></em>, <em class="sig-param"><span class="n">refid</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">traces</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">infer_others</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">mode</span><span class="o">=</span><span class="default_value">'append'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.EnergyCalibrator.addFeatures" title="Permalink to this definition">¶</a></dt>
<dd><p>Select or extract the equivalent landmarks (e.g. peaks) among all traces.</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>ranges: list/tuple</dt><dd><p>Collection of feature detection ranges, within which an algorithm
(i.e. 1D peak detector) with look for the feature.</p>
</dd>
<dt>refid: int | 0</dt><dd><p>Index of the reference trace (EDC).</p>
</dd>
<dt>traces: 2D array | None</dt><dd><p>Collection of energy dispersion curves (EDCs).</p>
</dd>
<dt>infer_others: bool | True</dt><dd><p>Option to infer the feature detection range in other traces (EDCs) from a given one.</p>
</dd>
<dt>mode: str | ‘append’</dt><dd><p>Specification on how to change the feature ranges (‘append’ or ‘replace’).</p>
</dd>
<dt><a href="#id5"><span class="problematic" id="id6">**</span></a>kwds: keyword arguments</dt><dd><p>Dictionarized keyword arguments for trace alignment (See <code class="docutils literal notranslate"><span class="pre">self.findCorrespondence()</span></code>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.EnergyCalibrator.calibrate">
<code class="sig-name descname">calibrate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">refid</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">ret</span><span class="o">=</span><span class="default_value">['coeffs']</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.EnergyCalibrator.calibrate" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the functional mapping between time-of-flight and the energy
scale using optimization methods.</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>refid: int | 0</dt><dd><p>The reference trace index (an integer).</p>
</dd>
<dt>ret: list | [‘coeffs’]</dt><dd><p>Options for return values (see <code class="docutils literal notranslate"><span class="pre">mpes.analysis.calibrateE()</span></code>).</p>
</dd>
<dt><a href="#id7"><span class="problematic" id="id8">**</span></a>kwds: keyword arguments</dt><dd><p>See available keywords for <code class="docutils literal notranslate"><span class="pre">mpes.analysis.calibrateE()</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.EnergyCalibrator.dup">
<em class="property">property </em><code class="sig-name descname">dup</code><a class="headerlink" href="#mpes.analysis.EnergyCalibrator.dup" title="Permalink to this definition">¶</a></dt>
<dd><p>The duplication number.</p>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.EnergyCalibrator.featureExtract">
<code class="sig-name descname">featureExtract</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ranges</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">traces</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.EnergyCalibrator.featureExtract" title="Permalink to this definition">¶</a></dt>
<dd><p>Select or extract the equivalent landmarks (e.g. peaks) among all traces.</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>ranges: list/tuple | None</dt><dd><p>Range in each trace to look for the peak feature, [start, end].</p>
</dd>
<dt>traces: 2D array | None</dt><dd><p>Collection of 1D spectra to use for calibration.</p>
</dd>
<dt><a href="#id9"><span class="problematic" id="id10">**</span></a>kwds: keyword arguments</dt><dd><p>See available keywords in <code class="docutils literal notranslate"><span class="pre">mpes.analysis.peaksearch()</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.EnergyCalibrator.findCorrespondence">
<em class="property">static </em><code class="sig-name descname">findCorrespondence</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sig_still</span></em>, <em class="sig-param"><span class="n">sig_mov</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'dtw'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.EnergyCalibrator.findCorrespondence" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the correspondence between two 1D traces by alignment.</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>sig_still, sig_mov: 1D array, 1D array</dt><dd><p>Input 1D signals.</p>
</dd>
<dt>method: str | ‘dtw’</dt><dd><p>Method for 1D signal correspondence detection (‘dtw’ or ‘ptw’).</p>
</dd>
<dt><a href="#id11"><span class="problematic" id="id12">**</span></a>kwds: keyword arguments</dt><dd><p>See available keywords for the following functions,
(1) <code class="docutils literal notranslate"><span class="pre">fastdtw.fastdtw()</span></code> (when <code class="docutils literal notranslate"><span class="pre">method=='dtw'</span></code>)
(2) <code class="docutils literal notranslate"><span class="pre">ptw.ptw.timeWarp()</span></code> (when <code class="docutils literal notranslate"><span class="pre">method=='ptw'</span></code>)</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>pathcorr: list</dt><dd><p>Pixel-wise path correspondences between two input 1D arrays (sig_still, sig_mov).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.EnergyCalibrator.nfiles">
<em class="property">property </em><code class="sig-name descname">nfiles</code><a class="headerlink" href="#mpes.analysis.EnergyCalibrator.nfiles" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of loaded files.</p>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.EnergyCalibrator.normalize">
<code class="sig-name descname">normalize</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.EnergyCalibrator.normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalize the spectra along an axis.</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><a href="#id13"><span class="problematic" id="id14">**</span></a>kwds: keyword arguments</dt><dd><p>See the keywords for <code class="docutils literal notranslate"><span class="pre">mpes.utils.normspec()</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.EnergyCalibrator.nranges">
<em class="property">property </em><code class="sig-name descname">nranges</code><a class="headerlink" href="#mpes.analysis.EnergyCalibrator.nranges" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of specified feature ranges.</p>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.EnergyCalibrator.ntraces">
<em class="property">property </em><code class="sig-name descname">ntraces</code><a class="headerlink" href="#mpes.analysis.EnergyCalibrator.ntraces" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of loaded/calculated traces.</p>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.EnergyCalibrator.read">
<code class="sig-name descname">read</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">form</span><span class="o">=</span><span class="default_value">'h5'</span></em>, <em class="sig-param"><span class="n">tracename</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">tofname</span><span class="o">=</span><span class="default_value">'ToF'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.EnergyCalibrator.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Read traces (e.g. energy dispersion curves) from files.</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>form: str | ‘h5’</dt><dd><p>Format of the files (‘h5’ or ‘mat’).</p>
</dd>
<dt>tracename: str | ‘’</dt><dd><p>Name of the group/attribute corresponding to the trace.</p>
</dd>
<dt>tofname: str | ‘ToF’</dt><dd><p>Name of the group/attribute corresponding to the time-of-flight.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.EnergyCalibrator.saveParameters">
<code class="sig-name descname">saveParameters</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">form</span><span class="o">=</span><span class="default_value">'h5'</span></em>, <em class="sig-param"><span class="n">save_addr</span><span class="o">=</span><span class="default_value">'./energy'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.EnergyCalibrator.saveParameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Save all the attributes of the workflow instance for later use
(e.g. energy scale conversion).</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>form: str | ‘h5’</dt><dd><p>The file format to save the attributes in (‘h5’/’hdf5’ or ‘mat’).</p>
</dd>
<dt>save_addr: str | ‘./energy’</dt><dd><p>The filename to save the files with.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.EnergyCalibrator.view">
<code class="sig-name descname">view</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">traces</span></em>, <em class="sig-param"><span class="n">segs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">peaks</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">show_legend</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">ret</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">display</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">backend</span><span class="o">=</span><span class="default_value">'matplotlib'</span></em>, <em class="sig-param"><span class="n">linekwds</span><span class="o">=</span><span class="default_value">{}</span></em>, <em class="sig-param"><span class="n">linesegkwds</span><span class="o">=</span><span class="default_value">{}</span></em>, <em class="sig-param"><span class="n">scatterkwds</span><span class="o">=</span><span class="default_value">{}</span></em>, <em class="sig-param"><span class="n">legkwds</span><span class="o">=</span><span class="default_value">{}</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.EnergyCalibrator.view" title="Permalink to this definition">¶</a></dt>
<dd><p>Display a plot showing line traces with annotation.</p>
<p><strong>Parameters</strong></p>
<dl>
<dt>traces: 2d array</dt><dd><p>Matrix of traces to visualize.</p>
</dd>
<dt>segs: list/tuple</dt><dd><p>Segments to be highlighted in the visualization.</p>
</dd>
<dt>peaks: 2d array</dt><dd><p>Peak positions for labelling the traces.</p>
</dd>
<dt>ret: bool</dt><dd><p>Return specification.</p>
</dd>
<dt>backend: str | ‘matplotlib’</dt><dd><p>Backend specification, choose between ‘matplotlib’ (static) or ‘bokeh’ (interactive).</p>
</dd>
<dt>linekwds: dict | {}</dt><dd><p>Keyword arguments for line plotting (see <code class="docutils literal notranslate"><span class="pre">matplotlib.pyplot.plot()</span></code>).</p>
</dd>
<dt>scatterkwds: dict | {}</dt><dd><p>Keyword arguments for scatter plot (see <code class="docutils literal notranslate"><span class="pre">matplotlib.pyplot.scatter()</span></code>).</p>
</dd>
<dt>legkwds: dict | {}</dt><dd><p>Keyword arguments for legend (see <code class="docutils literal notranslate"><span class="pre">matplotlib.pyplot.legend()</span></code>).</p>
</dd>
<dt><a href="#id15"><span class="problematic" id="id16">**</span></a>kwds: keyword arguments</dt><dd><table class="docutils align-default">
<colgroup>
<col style="width: 26%" />
<col style="width: 18%" />
<col style="width: 56%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>keyword</p></th>
<th class="head"><p>data type</p></th>
<th class="head"><p>meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>maincolor</p></td>
<td><p>str</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>labels</p></td>
<td><p>list</p></td>
<td><p>Labels for each curve</p></td>
</tr>
<tr class="row-even"><td><p>xaxis</p></td>
<td><p>1d array</p></td>
<td><p>x (horizontal) axis values</p></td>
</tr>
<tr class="row-odd"><td><p>title</p></td>
<td><p>str</p></td>
<td><p>Title of the plot</p></td>
</tr>
<tr class="row-even"><td><p>legend_location</p></td>
<td><p>str</p></td>
<td><p>Location of the plot legend</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="mpes.analysis.Model">
<em class="property">class </em><code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">Model</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="n">xvar</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.Model" title="Permalink to this definition">¶</a></dt>
<dd><p>Class of fitting curve models.</p>
<dl class="py method">
<dt id="mpes.analysis.Model._costfunc">
<code class="sig-name descname">_costfunc</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">inits</span></em>, <em class="sig-param"><span class="n">xv</span></em>, <em class="sig-param"><span class="n">form</span><span class="o">=</span><span class="default_value">'original'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.Model._costfunc" title="Permalink to this definition">¶</a></dt>
<dd><p>Define the cost function of the optimization process.</p>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.Model.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">inits</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'leastsq'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">fitkwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.Model.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the optimization.</p>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.Model.model_eval">
<code class="sig-name descname">model_eval</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">params</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.Model.model_eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the fitting model with given parameters.</p>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.Model.normalize">
<em class="property">static </em><code class="sig-name descname">normalize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.Model.normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalize n-dimensional data.</p>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.Model.partial_eval">
<code class="sig-name descname">partial_eval</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">params</span></em>, <em class="sig-param"><span class="n">part</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.Model.partial_eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate parts of a composite fitting model.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="mpes.analysis.MomentumCorrector">
<em class="property">class </em><code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">MomentumCorrector</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">image</span></em>, <em class="sig-param"><span class="n">rotsym</span><span class="o">=</span><span class="default_value">6</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector" title="Permalink to this definition">¶</a></dt>
<dd><p>Momentum distortion correction and momentum calibration workflow.</p>
<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector._featureUpdate">
<code class="sig-name descname">_featureUpdate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">center_det</span><span class="o">=</span><span class="default_value">'centroidnn'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector._featureUpdate" title="Permalink to this definition">¶</a></dt>
<dd><p>Update selected features.</p>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector._imageUpdate">
<code class="sig-name descname">_imageUpdate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector._imageUpdate" title="Permalink to this definition">¶</a></dt>
<dd><p>Update distortion-corrected images.</p>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector.applyDeformation">
<code class="sig-name descname">applyDeformation</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">image</span></em>, <em class="sig-param"><span class="n">ret</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.applyDeformation" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the deformation field to a specified image slice.</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>image: 2D array</dt><dd><p>Image slice to apply the deformation.</p>
</dd>
<dt>ret: bool | True</dt><dd><p>Option to return the image after deformation.</p>
</dd>
<dt><a href="#id17"><span class="problematic" id="id18">**</span></a>kwds: keyword arguments</dt><dd><dl class="field-list simple">
<dt class="field-odd">rdeform, cdeform</dt>
<dd class="field-odd"><p>2D array, 2D array | self.rdeform_field, self.cdeform_field
Row- and column-ordered deformation fields.</p>
</dd>
<dt class="field-even">interp_order</dt>
<dd class="field-even"><p>int | 1
Interpolation order.</p>
</dd>
<dt class="field-odd">others</dt>
<dd class="field-odd"><p>See <code class="docutils literal notranslate"><span class="pre">scipy.ndimage.map_coordinates()</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector.calcGeometricDistances">
<code class="sig-name descname">calcGeometricDistances</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.calcGeometricDistances" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate geometric distances involving the center and the vertices.
Distances calculated include center-vertex and nearest-neighbor vertex-vertex distances.</p>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector.calcSymmetryScores">
<code class="sig-name descname">calcSymmetryScores</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">symtype</span><span class="o">=</span><span class="default_value">'rotation'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.calcSymmetryScores" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the symmetry scores from geometric quantities.</p>
<p><strong>Paramters</strong></p>
<dl class="simple">
<dt>symtype: str | ‘rotation’</dt><dd><p>Type of symmetry.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector.calibrate">
<code class="sig-name descname">calibrate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">image</span></em>, <em class="sig-param"><span class="n">point_from</span></em>, <em class="sig-param"><span class="n">point_to</span></em>, <em class="sig-param"><span class="n">dist</span></em>, <em class="sig-param"><span class="n">ret</span><span class="o">=</span><span class="default_value">'coeffs'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.calibrate" title="Permalink to this definition">¶</a></dt>
<dd><p>Calibration of the momentum axes. Obtain all calibration-related values,
return only the ones requested.</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>image: 2d array</dt><dd><p>Image slice to construct the calibration function.</p>
</dd>
<dt>point_from, point_to: list/tuple, list/tuple</dt><dd><p>Pixel coordinates of the two special points in (row, col) ordering.</p>
</dd>
<dt>dist: float</dt><dd><p>Distance between the two selected points in inverse Angstrom.</p>
</dd>
<dt>ret: str | ‘coeffs’</dt><dd><p>Specification of return values (‘axes’, ‘extent’, ‘coeffs’, ‘grid’, ‘func’, ‘all’).</p>
</dd>
<dt><a href="#id19"><span class="problematic" id="id20">**</span></a>kwds: keyword arguments</dt><dd><p>See arguments in <code class="docutils literal notranslate"><span class="pre">mpes.analysis.calibrateE()</span></code>.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Specified calibration parameters in a dictionary.</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector.coordinateTransform">
<code class="sig-name descname">coordinateTransform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">type</span></em>, <em class="sig-param"><span class="n">keep</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">ret</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">interp_order</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">mapkwds</span><span class="o">=</span><span class="default_value">{}</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.coordinateTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a pixel-wise coordinate transform to an image.</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>type: str</dt><dd><p>Type of deformation to apply to image slice.</p>
</dd>
<dt>keep: bool | False</dt><dd><p>Option to keep the specified coordinate transform.</p>
</dd>
<dt>ret: bool | False</dt><dd><p>Option to return transformed image slice.</p>
</dd>
<dt>interp_order: int | 1</dt><dd><p>Interpolation order for filling in missed pixels.</p>
</dd>
<dt>mapkwds: dict | {}</dt><dd><p>Additional arguments passed to <code class="docutils literal notranslate"><span class="pre">scipy.ndimage.map_coordinates()</span></code>.</p>
</dd>
<dt><a href="#id21"><span class="problematic" id="id22">**</span></a>kwds: keyword arguments</dt><dd><p>Additional arguments in specific deformation field. See <code class="docutils literal notranslate"><span class="pre">symmetrize.sym</span></code> module.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector.correct">
<code class="sig-name descname">correct</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">axis</span></em>, <em class="sig-param"><span class="n">use_composite_transform</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">update</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">use_deform_field</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">updatekwds</span><span class="o">=</span><span class="default_value">{}</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.correct" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a 2D transform to a stack of 2D images (3D) along a specific axis.</p>
<p><strong>Parameters</strong></p>
<dl>
<dt>axis: int</dt><dd><p>Axis for slice selection.</p>
</dd>
<dt>use_composite_transform: bool | False</dt><dd><p>Option to use the composite transform involving the rotation.</p>
</dd>
<dt>update: bool | False</dt><dd><p>Option to update the existing figure attributes.</p>
</dd>
<dt>use_deform_field: bool | False</dt><dd><p>Option to use deformation field for distortion correction.</p>
</dd>
<dt><a href="#id23"><span class="problematic" id="id24">**</span></a>kwds: keyword arguments</dt><dd><table class="docutils align-default">
<colgroup>
<col style="width: 14%" />
<col style="width: 20%" />
<col style="width: 66%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>keyword</p></th>
<th class="head"><p>data type</p></th>
<th class="head"><p>meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>image</p></td>
<td><p>2d array</p></td>
<td><p>3D image for correction</p></td>
</tr>
<tr class="row-odd"><td><p>dfield</p></td>
<td><p>list/tuple</p></td>
<td><p>row and column deformation field</p></td>
</tr>
<tr class="row-even"><td><p>warping</p></td>
<td><p>2d array</p></td>
<td><p>2D transform correction matrix</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector.featureExtract">
<code class="sig-name descname">featureExtract</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">image</span></em>, <em class="sig-param"><span class="n">direction</span><span class="o">=</span><span class="default_value">'ccw'</span></em>, <em class="sig-param"><span class="n">type</span><span class="o">=</span><span class="default_value">'points'</span></em>, <em class="sig-param"><span class="n">center_det</span><span class="o">=</span><span class="default_value">'centroidnn'</span></em>, <em class="sig-param"><span class="n">symscores</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.featureExtract" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Extract features from the selected 2D slice.</dt><dd><p>Currently only point feature detection is implemented.</p>
</dd>
</dl>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>image: 2d array</dt><dd><p>The image slice to extract features from.</p>
</dd>
<dt>direction: str | ‘ccw’</dt><dd><p>The circular direction to reorder the features in (‘cw’ or ‘ccw’).</p>
</dd>
<dt>type: str | ‘points’</dt><dd><p>The type of features to extract.</p>
</dd>
<dt>center_det: str | ‘centroidnn’</dt><dd><p>Specification of center detection method (‘centroidnn’, ‘centroid’, None).</p>
</dd>
<dt><a href="#id25"><span class="problematic" id="id26">**</span></a>kwds: keyword arguments</dt><dd><p>Extra keyword arguments for <code class="docutils literal notranslate"><span class="pre">symmetrize.pointops.peakdetect2d()</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector.features">
<em class="property">property </em><code class="sig-name descname">features</code><a class="headerlink" href="#mpes.analysis.MomentumCorrector.features" title="Permalink to this definition">¶</a></dt>
<dd><p>Dictionary of detected features for the symmetrization process.
<code class="docutils literal notranslate"><span class="pre">self.features</span></code> is a derived attribute from existing ones.</p>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector.getWarpFunction">
<em class="property">static </em><code class="sig-name descname">getWarpFunction</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.getWarpFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct warping function to apply to other datasets.
# TODO: turn this into a fully operational method.</p>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector.importBinningParameters">
<code class="sig-name descname">importBinningParameters</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">parp</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.importBinningParameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Import parameters of binning used for correction image from parallelHDF5Processor Class instance</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>parp: instance of the <code class="docutils literal notranslate"><span class="pre">ParallelHDF5Processor</span></code> class</dt><dd><p>Import parameters used for creation of the distortion-corrected image.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector.intensityTransform">
<code class="sig-name descname">intensityTransform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">type</span><span class="o">=</span><span class="default_value">'rot_sym'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.intensityTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply pixel-wise intensity transform.</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>type: str | ‘rot_sym’</dt><dd><p>Type of intensity transform.</p>
</dd>
</dl>
<p><a href="#id27"><span class="problematic" id="id28">**</span></a>kwds: keyword arguments</p>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector.linWarpEstimate">
<code class="sig-name descname">linWarpEstimate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">weights</span><span class="o">=</span><span class="default_value">1, 1, 1</span></em>, <em class="sig-param"><span class="n">optfunc</span><span class="o">=</span><span class="default_value">'minimize'</span></em>, <em class="sig-param"><span class="n">optmethod</span><span class="o">=</span><span class="default_value">'Nelder-Mead'</span></em>, <em class="sig-param"><span class="n">ret</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">warpkwds</span><span class="o">=</span><span class="default_value">{}</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.linWarpEstimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the homography-based deformation field using landmark correspondences.</p>
<p><strong>Parameters</strong></p>
<dl>
<dt>weights: tuple/list/array | (1, 1, 1)</dt><dd><p>Weights added to the terms in the optimizer. The terms are assigned
to the cost functions of (1) centeredness, (2) center-vertex symmetry,
(3) vertex-vertex symmetry, respectively.</p>
</dd>
<dt>optfunc, optmethod: str/func, str | ‘minimize’, ‘Nelder-Mead’</dt><dd><p>Name of the optimizer function and the optimization method.
See description in <code class="docutils literal notranslate"><span class="pre">mpes.analysis.sym.target_set_optimize()</span></code>.</p>
</dd>
<dt>ret: bool | True</dt><dd><p>Specify if returning the corrected image slice.</p>
</dd>
<dt>warpkwds: dictionary | {}</dt><dd><p>Additional arguments passed to <code class="docutils literal notranslate"><span class="pre">symmetrize.sym.imgWarping()</span></code>.</p>
</dd>
<dt><a href="#id29"><span class="problematic" id="id30">**</span></a>kwds: keyword arguments</dt><dd><table class="docutils align-default">
<colgroup>
<col style="width: 14%" />
<col style="width: 16%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>keyword</p></th>
<th class="head"><p>data type</p></th>
<th class="head"><p>meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>niter</p></td>
<td><p>int</p></td>
<td><p>Maximum number of iterations</p></td>
</tr>
<tr class="row-odd"><td><p>landmarks</p></td>
<td><p>list/array</p></td>
<td><p>Symmetry landmarks selected for registration</p></td>
</tr>
<tr class="row-even"><td><p>fitinit</p></td>
<td><p>tuple/list</p></td>
<td><p>Initial conditions for fitting</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Corrected 2D image slice (when <code class="docutils literal notranslate"><span class="pre">ret=True</span></code> is specified in the arguments).</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector.resetDeformation">
<code class="sig-name descname">resetDeformation</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.resetDeformation" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset the deformation field.</p>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector.rotate">
<code class="sig-name descname">rotate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">angle</span><span class="o">=</span><span class="default_value">'auto'</span></em>, <em class="sig-param"><span class="n">ret</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate 2D image in the homogeneous coordinate.</p>
<p><strong>Parameters</strong></p>
<dl>
<dt>angle: float/str</dt><dd><p>Angle of rotation (specify ‘auto’ to use automated estimation).</p>
</dd>
<dt>ret: bool | False</dt><dd><p>Return specification (True/False)</p>
</dd>
<dt><a href="#id31"><span class="problematic" id="id32">**</span></a>kwds: keyword arguments</dt><dd><table class="docutils align-default">
<colgroup>
<col style="width: 13%" />
<col style="width: 18%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>keyword</p></th>
<th class="head"><p>data type</p></th>
<th class="head"><p>meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>image</p></td>
<td><p>2d array</p></td>
<td><p>2D image for correction</p></td>
</tr>
<tr class="row-odd"><td><p>center</p></td>
<td><p>tuple/list</p></td>
<td><p>pixel coordinates of the image center</p></td>
</tr>
<tr class="row-even"><td><p>scale</p></td>
<td><p>float</p></td>
<td><p>scaling factor in rotation</p></td>
</tr>
</tbody>
</table>
<p>See <code class="docutils literal notranslate"><span class="pre">symmetrize.sym.sym_pose_estimate()</span></code> for other keywords.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector.saveImage">
<code class="sig-name descname">saveImage</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">form</span><span class="o">=</span><span class="default_value">'tiff'</span></em>, <em class="sig-param"><span class="n">save_addr</span><span class="o">=</span><span class="default_value">'./'</span></em>, <em class="sig-param"><span class="n">dtyp</span><span class="o">=</span><span class="default_value">'float32'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.saveImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the distortion-corrected dataset (image only, without axes).</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>form: str | ‘tiff’</dt><dd><p>File format for saving the corrected image (‘tiff’ or ‘mat’).</p>
</dd>
<dt>save_addr: str | ‘./’</dt><dd><p>The address to save the file at.</p>
</dd>
<dt>dtyp: str | ‘float32’</dt><dd><p>Data type (in case conversion if needed).</p>
</dd>
<dt><a href="#id33"><span class="problematic" id="id34">**</span></a>kwds: keyword arguments</dt><dd><p>See keywords from <code class="docutils literal notranslate"><span class="pre">tifffile.imsave()</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector.saveParameters">
<code class="sig-name descname">saveParameters</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">form</span><span class="o">=</span><span class="default_value">'h5'</span></em>, <em class="sig-param"><span class="n">save_addr</span><span class="o">=</span><span class="default_value">'./momentum'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.saveParameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Save all the attributes of the workflow instance for later use
(e.g. momentum scale conversion, reconstructing the warping map function).</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>form: str | ‘h5’</dt><dd><p>File format to for saving the parameters (‘h5’/’hdf5’, ‘mat’)</p>
</dd>
<dt>save_addr: str | ‘./momentum’</dt><dd><p>The address for the to be saved file.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector.selectSlice2D">
<code class="sig-name descname">selectSlice2D</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">selector</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.selectSlice2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Select (hyper)slice from a (hyper)volume.</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>selector: slice object/list/int</dt><dd><p>Selector along the specified axis to extract the slice (image).
Use the construct slice(start, stop, step) to select a range of images and sum them.
Use an integer to specify only a particular slice.</p>
</dd>
<dt>axis: int | 2</dt><dd><p>Axis along which to select the image.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector.splineWarpEstimate">
<code class="sig-name descname">splineWarpEstimate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">image</span></em>, <em class="sig-param"><span class="n">include_center</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">fixed_center</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">iterative</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">interp_order</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">update</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">ret</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.splineWarpEstimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the spline deformation field using thin plate spline registration.</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>image: 2D array</dt><dd><p>Image slice to be corrected.</p>
</dd>
<dt>include_center: bool | True</dt><dd><p>Option to include the image center/centroid in the registration process.</p>
</dd>
<dt>fixed_center: bool | True</dt><dd><p>Option to have a fixed center during registration-based symmetrization.</p>
</dd>
<dt>iterative: bool | False</dt><dd><p>Option to use the iterative approach (may not work in all cases).</p>
</dd>
<dt>interp_order: int | 1</dt><dd><p>Order of interpolation (see <code class="docutils literal notranslate"><span class="pre">scipy.ndimage.map_coordinates()</span></code>).</p>
</dd>
<dt>update: bool | False</dt><dd><p>Option to keep the spline-deformed image as corrected one.</p>
</dd>
<dt>ret: bool | False</dt><dd><p>Option to return corrected image slice.</p>
</dd>
<dt><a href="#id35"><span class="problematic" id="id36">**</span></a>kwds: keyword arguments</dt><dd><dl class="field-list simple">
<dt class="field-odd">landmarks</dt>
<dd class="field-odd"><p>list/array | self.pouter_ord
Landmark positions (row, column) used for registration.</p>
</dd>
<dt class="field-even">new_centers</dt>
<dd class="field-even"><p>dict | {}
User-specified center positions for the reference and target sets.
{‘lmkcenter’: (row, col), ‘targcenter’: (row, col)}</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector.symscores">
<em class="property">property </em><code class="sig-name descname">symscores</code><a class="headerlink" href="#mpes.analysis.MomentumCorrector.symscores" title="Permalink to this definition">¶</a></dt>
<dd><p>Dictionary of symmetry-related scores.</p>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector.transform">
<em class="property">static </em><code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">points</span></em>, <em class="sig-param"><span class="n">transmat</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Coordinate transform of a point set in the (row, column) formulation.</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>points: list/array</dt><dd><p>Cartesian pixel coordinates of the points to be transformed.</p>
</dd>
<dt>transmat: 2D array</dt><dd><p>The transform matrix.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Transformed point coordinates.</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector.update">
<code class="sig-name descname">update</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">content</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update specific attributes of the class.</p>
<p><strong>Parameters</strong></p>
<dl>
<dt>content: str | ‘all’</dt><dd><p>‘feature’ = update only feature attributes</p>
<p>‘image’ = update only image-related attributes</p>
<p>‘all’ = update both feature and image-related attributes</p>
</dd>
<dt><a href="#id37"><span class="problematic" id="id38">**</span></a>kwds: keyword arguments</dt><dd><p>Extra keyword arguments passed into <code class="docutils literal notranslate"><span class="pre">self._featureUpdate()</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector.updateDeformation">
<code class="sig-name descname">updateDeformation</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">rdeform</span></em>, <em class="sig-param"><span class="n">cdeform</span></em>, <em class="sig-param"><span class="n">reset</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.updateDeformation" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the deformation field.</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>rdeform, cdeform: 2D array, 2D array</dt><dd><p>Row- and column-ordered deformation fields.</p>
</dd>
<dt>reset: bool | False</dt><dd><p>Option to reset the deformation field.</p>
</dd>
<dt><a href="#id39"><span class="problematic" id="id40">**</span></a>kwds: keyword arguments</dt><dd><p>See <code class="docutils literal notranslate"><span class="pre">mpes.analysis.MomentumCorrector.resetDeformation()</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="mpes.analysis.MomentumCorrector.view">
<code class="sig-name descname">view</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">origin</span><span class="o">=</span><span class="default_value">'lower'</span></em>, <em class="sig-param"><span class="n">cmap</span><span class="o">=</span><span class="default_value">'terrain_r'</span></em>, <em class="sig-param"><span class="n">figsize</span><span class="o">=</span><span class="default_value">4, 4</span></em>, <em class="sig-param"><span class="n">points</span><span class="o">=</span><span class="default_value">{}</span></em>, <em class="sig-param"><span class="n">annotated</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">display</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">backend</span><span class="o">=</span><span class="default_value">'matplotlib'</span></em>, <em class="sig-param"><span class="n">ret</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">imkwds</span><span class="o">=</span><span class="default_value">{}</span></em>, <em class="sig-param"><span class="n">scatterkwds</span><span class="o">=</span><span class="default_value">{}</span></em>, <em class="sig-param"><span class="n">crosshair</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">radii</span><span class="o">=</span><span class="default_value">[50, 100, 150]</span></em>, <em class="sig-param"><span class="n">crosshair_thickness</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.view" title="Permalink to this definition">¶</a></dt>
<dd><p>Display image slice with specified annotations.</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>origin: str | ‘lower’</dt><dd><p>Figure origin specification (‘lower’ or ‘upper’).</p>
</dd>
<dt>cmap: str | ‘terrain_r’</dt><dd><p>Colormap specification.</p>
</dd>
<dt>figsize: tuple/list | (4, 4)</dt><dd><p>Figure size.</p>
</dd>
<dt>points: dict | {}</dt><dd><p>Points for annotation.</p>
</dd>
<dt>annotated: bool | False</dt><dd><p>Option for annotation.</p>
</dd>
<dt>display: bool | True</dt><dd><p>Display option when using <code class="docutils literal notranslate"><span class="pre">bokeh</span></code> to render interactively.</p>
</dd>
<dt>backend: str | ‘matplotlib’</dt><dd><p>Visualization backend specification.
:’matplotlib’: use static display rendered by matplotlib.
:’bokeh’: use interactive display rendered by bokeh.</p>
</dd>
<dt>ret: bool | False</dt><dd><p>Option to return figure and axis objects.</p>
</dd>
<dt>imkwd: dict | {}</dt><dd><p>Keyword arguments for <code class="docutils literal notranslate"><span class="pre">matplotlib.pyplot.imshow()</span></code>.</p>
</dd>
<dt>crosshair: bool | False</dt><dd><p>Display option to plot circles around center self.pcent. Works only in bokeh backend.</p>
</dd>
<dt>radii: list | [50,100,150]</dt><dd><p>Radii of circles to plot when crosshair optin is activated.</p>
</dd>
<dt>crosshair_thickness: int | 1</dt><dd><p>Thickness of crosshair circles.</p>
</dd>
<dt><a href="#id41"><span class="problematic" id="id42">**</span></a>kwds: keyword arguments</dt><dd><p>General extra arguments for the plotting procedure.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="mpes.analysis._datacheck_peakdetect">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">_datacheck_peakdetect</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x_axis</span></em>, <em class="sig-param"><span class="n">y_axis</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis._datacheck_peakdetect" title="Permalink to this definition">¶</a></dt>
<dd><p>Input format checking</p>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis._rotate2d">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">_rotate2d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">image</span></em>, <em class="sig-param"><span class="n">center</span></em>, <em class="sig-param"><span class="n">angle</span></em>, <em class="sig-param"><span class="n">scale</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis._rotate2d" title="Permalink to this definition">¶</a></dt>
<dd><p>2D matrix scaled rotation carried out in the homogenous coordinate.</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>image: 2d array</dt><dd><p>Image matrix.</p>
</dd>
<dt>center: tuple/list</dt><dd><p>Center of the image (row pixel, column pixel).</p>
</dd>
<dt>angle: numeric</dt><dd><p>Angle of image rotation.</p>
</dd>
<dt>scale: numeric | 1</dt><dd><p>Scale of image rotation.</p>
</dd>
</dl>
<p><strong>Returns</strong></p>
<dl class="simple">
<dt>image_rot: 2d array</dt><dd><p>Rotated image matrix.</p>
</dd>
<dt>rotmat: 2d array</dt><dd><p>Rotation matrix in the homogeneous coordinate system.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis._signedmask">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">_signedmask</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">imr</span></em>, <em class="sig-param"><span class="n">imc</span></em>, <em class="sig-param"><span class="n">maskr</span></em>, <em class="sig-param"><span class="n">maskc</span></em>, <em class="sig-param"><span class="n">sign</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis._signedmask" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a binary mask using the masked coordinates.</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>imr, imc: int</dt><dd><p>Row and column size of the image.</p>
</dd>
<dt>maskr, maskc: 1D array</dt><dd><p>Row and column coordinates of the masked pixels.</p>
</dd>
<dt>sign: int/str</dt><dd><p>Value of the masked region, (0, 1, ‘nan’, or ‘xnan’).</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>mask: 2D array</dt><dd><p>Mask matrix.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.applyWarping">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">applyWarping</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">imgstack</span></em>, <em class="sig-param"><span class="n">axis</span></em>, <em class="sig-param"><span class="n">hgmat</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.applyWarping" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply warping transform for a stack of images along an axis.</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>imgstack: 3D array</dt><dd><p>Image stack before warping correction.</p>
</dd>
<dt>axis: int</dt><dd><p>Axis to iterate over to apply the transform.</p>
</dd>
<dt>hgmat: 2D array</dt><dd><p>Homography matrix.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>imstack_transformed: 3D array</dt><dd><p>Stack of images after correction for warping.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.apply_mask_along">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">apply_mask_along</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">arr</span></em>, <em class="sig-param"><span class="n">mask</span></em>, <em class="sig-param"><span class="n">axes</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.apply_mask_along" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a mask in a low dimensional slice throughout a high-dimensional array.</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>arr: nD array</dt><dd><p>Multidimensional array for masking.</p>
</dd>
<dt>mask: nD array</dt><dd><p>Mask to apply.</p>
</dd>
<dt>axes: list/tuple of int | None</dt><dd><p>The axes to apply the mask to.</p>
</dd>
</dl>
<p><strong>Return</strong>
maskedarr: nD array</p>
<blockquote>
<div><p>Masked multidimensional array.</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.bandpath_map">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">bandpath_map</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">bsvol</span></em>, <em class="sig-param"><span class="n">pathr</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">pathc</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">path_coords</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">eaxis</span><span class="o">=</span><span class="default_value">2</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'analog'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.bandpath_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract band diagram map from 2D/3D data.</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>bsvol: 2D/3D array</dt><dd><p>Volumetric band structure data.</p>
</dd>
<dt>pathr, pathc: 1D array | None, None</dt><dd><p>Row and column pixel coordinates along the band path (ignored if path_coords is given).</p>
</dd>
<dt>path_coords: 2D array | None</dt><dd><p>Combined row and column pixel coordinates of the band path.</p>
</dd>
<dt>eaxis: int | 2</dt><dd><p>Energy axis index.</p>
</dd>
<dt>method: str | ‘analog’</dt><dd><p>Method for generating band path map (‘analog’ or ‘digital’).
:’analog’: Using an interpolation scheme to calculate the exact pixel values.
:’digital’: Using only the approximating pixel values (Bresenham’s algorithm).</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>bpm: 2D array</dt><dd><p>Band path map (BPM) sampled from the volumetric data.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.blocknorm">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">blocknorm</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">mavg_axis</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">blockwidth</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.blocknorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Block-thresholding 2D data.</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>data: ndarray</dt><dd><p>Data to normalize.</p>
</dd>
<dt>mavg_axis: int | 0</dt><dd><p>Axis to move the block along.</p>
</dd>
<dt>blockwidth: int | 1</dt><dd><p>Width of the moving block.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>datanorm: ndarray</dt><dd><p>Block-normalized data.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.bootstrapfit">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">bootstrapfit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">axval</span></em>, <em class="sig-param"><span class="n">model</span></em>, <em class="sig-param"><span class="n">params</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">dfcontainer</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">pbar</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">pbenv</span><span class="o">=</span><span class="default_value">'classic'</span></em>, <em class="sig-param"><span class="n">ret</span><span class="o">=</span><span class="default_value">'all'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.bootstrapfit" title="Permalink to this definition">¶</a></dt>
<dd><p>Line-by-line fitting via bootstrapping fitted parameters from one line to the next.</p>
<p><strong>Parameters</strong></p>
<dl>
<dt>data: ndarray</dt><dd><p>Data used in fitting.</p>
</dd>
<dt>axval: list/numeric array</dt><dd><p>Value for the axis.</p>
</dd>
<dt>model: lmfit Model object</dt><dd><p>The fitting model.</p>
</dd>
<dt>params: lmfit Parameters object</dt><dd><p>Initial guesses for fitting parameters.</p>
</dd>
<dt>axis: int | 0</dt><dd><p>The axis of the data to fit.</p>
</dd>
<dt>dfcontainer: pandas DataFrame | None</dt><dd><p>Dataframe container for the fitting parameters.</p>
</dd>
<dt>pbar: bool | False</dt><dd><p>Progress bar condition.</p>
</dd>
<dt>pbenv: str | ‘classic’</dt><dd><p>Progress bar environment (‘classic’ for generic version, ‘notebook’ for
notebook compatible version).</p>
</dd>
<dt><a href="#id43"><span class="problematic" id="id44">**</span></a>kwds: keyword arguments</dt><dd><table class="docutils align-default">
<colgroup>
<col style="width: 14%" />
<col style="width: 11%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>keyword</p></th>
<th class="head"><p>data type</p></th>
<th class="head"><p>meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>maxiter</p></td>
<td><p>int</p></td>
<td><p>maximum iteration per fit (default = 20)</p></td>
</tr>
<tr class="row-odd"><td><p>concat</p></td>
<td><p>bool</p></td>
<td><dl class="simple">
<dt>concatenate the fit parameters to DataFrame input</dt><dd><p>False (default) = no concatenation, use an empty DataFrame to start
True = with concatenation to input DataFrame</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><p>bgremove</p></td>
<td><p>bool</p></td>
<td><p>toggle for background removal (default = True)</p></td>
</tr>
<tr class="row-odd"><td><p>flipped</p></td>
<td><p>bool</p></td>
<td><dl class="simple">
<dt>toggle for fitting start position</dt><dd><p>(if flipped, fitting start from the last line)</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><p>limpropagate</p></td>
<td><p>bool</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>verbose</p></td>
<td><p>bool</p></td>
<td><p>toggle for output message (default = False)</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>
<p><strong>Returns</strong></p>
<dl class="simple">
<dt>df_fit: pandas DataFrame</dt><dd><p>Dataframe container populated with obtained fitting parameters.</p>
</dd>
<dt>data_nobg: ndarray</dt><dd><p>Background-removed (Shirley-type) traces.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.build_dynamic_matrix">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">build_dynamic_matrix</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fitparams</span></em>, <em class="sig-param"><span class="n">display_range</span><span class="o">=</span><span class="default_value">slice(None, None, None)</span></em>, <em class="sig-param"><span class="n">pre_t0_range</span><span class="o">=</span><span class="default_value">slice(None, 1, None)</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.build_dynamic_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct the dynamic matrix from the fitting results. For each fitting parameter, construct time-dependent value, time-dependent absolute and relative changes.</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>fitparams: 3D ndarray</dt><dd><p>fitting output</p>
</dd>
<dt>display_range: slice object | slice(None, None, None)</dt><dd><p>display time range of the fitting parameters (default = full range)</p>
</dd>
<dt>pre_t0_range: slice object | slice(None, 1, None)</dt><dd><p>time range regarded as before time-zero</p>
</dd>
</dl>
<p><strong>Returns</strong></p>
<dl class="simple">
<dt>dyn_matrix: 4D ndarray</dt><dd><p>calculated dynamic matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.calibrateE">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">calibrateE</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pos</span></em>, <em class="sig-param"><span class="n">vals</span></em>, <em class="sig-param"><span class="n">order</span><span class="o">=</span><span class="default_value">3</span></em>, <em class="sig-param"><span class="n">refid</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">ret</span><span class="o">=</span><span class="default_value">'func'</span></em>, <em class="sig-param"><span class="n">E0</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">Eref</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">t</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">aug</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'lstsq'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.calibrateE" title="Permalink to this definition">¶</a></dt>
<dd><p>Energy calibration by nonlinear least squares fitting of spectral landmarks on
a set of (energy dispersion curves (EDCs). This amounts to solving for the
coefficient vector, a, in the system of equations T.a = b. Here T is the
differential drift time matrix and b the differential bias vector, and
assuming that the energy-drift-time relationship can be written in the form,
E = sum_n (a_n * t**n) + E0</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>pos: list/array</dt><dd><p>Positions of the spectral landmarks (e.g. peaks) in the EDCs.</p>
</dd>
<dt>vals: list/array</dt><dd><p>Bias voltage value associated with each EDC.</p>
</dd>
<dt>order: int | 3</dt><dd><p>Polynomial order of the fitting function.</p>
</dd>
<dt>refid: int | 0</dt><dd><p>Reference dataset index, varies from 0 to vals.size - 1.</p>
</dd>
<dt>ret: str | ‘func’</dt><dd><p>Return type, including ‘func’, ‘coeffs’, ‘full’, and ‘axis’ (see below).</p>
</dd>
<dt>E0: float | None</dt><dd><p>Constant energy offset.</p>
</dd>
<dt>t: numeric array | None</dt><dd><p>Drift time.</p>
</dd>
<dt>aug: int | 1</dt><dd><p>Fitting dimension augmentation (1=no change, 2=double, etc).</p>
</dd>
</dl>
<p><strong>Returns</strong></p>
<dl class="simple">
<dt>pfunc: partial function</dt><dd><p>Calibrating function with determined polynomial coefficients (except the constant offset).</p>
</dd>
<dt>ecalibdict: dict</dt><dd><p>A dictionary of fitting parameters including the following,
:coeffs: Fitted polynomial coefficients (the a’s).
:offset: Minimum time-of-flight corresponding to a peak.
:Tmat: the T matrix (differential time-of-flight) in the equation Ta=b.
:bvec: the b vector (differential bias) in the fitting Ta=b.
:axis: Fitted energy axis.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.calibrateK">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">calibrateK</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">img</span></em>, <em class="sig-param"><span class="n">pxla</span></em>, <em class="sig-param"><span class="n">pxlb</span></em>, <em class="sig-param"><span class="n">k_ab</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kcoorda</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kcoordb</span><span class="o">=</span><span class="default_value">[0.0, 0.0]</span></em>, <em class="sig-param"><span class="n">equiscale</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">ret</span><span class="o">=</span><span class="default_value">['axes']</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.calibrateK" title="Permalink to this definition">¶</a></dt>
<dd><p>Momentum axes calibration using the pixel positions of two symmetry points (a and b)
and the absolute coordinate of a single point (b), defaulted to [0., 0.]. All coordinates
should be specified in the (row_index, column_index) format. See the equiscale option for
details on the specifications of point coordinates.</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>img: 2D array</dt><dd><p>An energy cut of the band structure.</p>
</dd>
<dt>pxla, pxlb: list/tuple/1D array</dt><dd><p>Pixel coordinates of the two symmetry points (a and b). Point b has the
default coordinates [0., 0.] (see below).</p>
</dd>
<dt>k_ab: float | None</dt><dd><p>The known momentum space distance between the two symmetry points.</p>
</dd>
<dt>kcoorda: list/tuple/1D array | None</dt><dd><p>Momentum coordinates of the symmetry point a.</p>
</dd>
<dt>kcoordb: list/tuple/1D array | [0., 0.]</dt><dd><p>Momentum coordinates of the symmetry point b (krow, kcol), default to k-space center.</p>
</dd>
<dt>equiscale: bool | False</dt><dd><p>Option to adopt equal scale along both the row and column directions.
:True: Use a uniform scale for both x and y directions in the image coordinate system.
This applies to the situation where the points a and b are (close to) parallel with one
of the two image axes.
:False: Calculate the momentum scale for both x and y directions separately. This applies
to the situation where the points a and b are sufficiently different in both x and y directions
in the image coordinate system.</p>
</dd>
<dt>ret: list | [‘axes’]</dt><dd><p>Return type specification, options include ‘axes’, ‘extent’, ‘coeffs’, ‘grid’, ‘func’, ‘all’.</p>
</dd>
</dl>
<p><strong>Returns</strong></p>
<dl class="simple">
<dt>k_row, k_col: 1D array</dt><dd><p>Momentum coordinates of the row and column.</p>
</dd>
<dt>axis_extent: list</dt><dd><p>Extent of the two momentum axis (can be used directly in imshow).</p>
</dd>
<dt>k_rowgrid, k_colgrid: 2D array</dt><dd><p>Row and column mesh grid generated from the coordinates
(can be used directly in pcolormesh).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.circmask">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">circmask</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">img</span></em>, <em class="sig-param"><span class="n">rcent</span></em>, <em class="sig-param"><span class="n">ccent</span></em>, <em class="sig-param"><span class="n">rad</span></em>, <em class="sig-param"><span class="n">sign</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">ret</span><span class="o">=</span><span class="default_value">'mask'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.circmask" title="Permalink to this definition">¶</a></dt>
<dd><p>Use a circular binary mask to cover an image.</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>img: 2D array</dt><dd><p>Input image to be masked.</p>
</dd>
<dt>rcent: float</dt><dd><p>Row center position.</p>
</dd>
<dt>ccent: float</dt><dd><p>Column center position.</p>
</dd>
<dt>rad: float</dt><dd><p>Radius of circle.</p>
</dd>
<dt>sign: int/str | 1</dt><dd><p>Value of the masked region (0, 1, ‘nan’ or ‘xnan’).
‘xnan’ means the masked region is 1 and the other region nan.</p>
</dd>
<dt>ret: str | ‘mask’</dt><dd><p>Return type (‘mask’, ‘masked_image’)</p>
</dd>
<dt>kwds: keyword arguments</dt><dd></dd>
</dl>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>cmask or cmask*img: 2D array</dt><dd><p>Mask only or masked image</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.curvature2d">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">curvature2d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">image</span></em>, <em class="sig-param"><span class="n">cx</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">cy</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.curvature2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Implementation of 2D curvature calculation.
The formula follows Zhang et al. Rev. Sci. Instrum. 82, 043712 (2011).</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>image: 2D array</dt><dd><p>2D image obtained from measurement.</p>
</dd>
<dt>cx, cy: numeric, numeric | 1, 1</dt><dd><p>Scaling parameters in x and y directions.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.func_add">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">func_add</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">funcs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.func_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Addition of an arbitray number of functions</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><a href="#id45"><span class="problematic" id="id46">*</span></a>funcs: list/tuple</dt><dd><p>functions to combine</p>
</dd>
</dl>
<p><strong>Returns</strong></p>
<dl class="simple">
<dt>funcsum: function</dt><dd><p>functional sum</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.func_update">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">func_update</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="n">suffix</span><span class="o">=</span><span class="default_value">''</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.func_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Attach a suffix to parameter names and their instances
in the expression of a function</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>func: function</dt><dd><p>input function</p>
</dd>
<dt>suffix: str | ‘’</dt><dd><p>suffix to attach to parameter names</p>
</dd>
</dl>
<p><strong>Returns</strong></p>
<dl class="simple">
<dt>params: list of str</dt><dd><p>updated function parameters</p>
</dd>
<dt>expr: str</dt><dd><p>updated function expression</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.gaussian">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">gaussian</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">feval</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">vardict</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.gaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>1D Gaussian lineshape model. Returns numerical values if <code class="docutils literal notranslate"><span class="pre">feval=True</span></code>.</p>
<p><strong>Parameters</strong></p>
<dl>
<dt>feval: bool | False</dt><dd><p>Option to evaluate function.</p>
</dd>
<dt>vardict: dict | None</dt><dd><p>Dictionary containing values for the variables named as follows (as dictionary keys).</p>
<p><code class="docutils literal notranslate"><span class="pre">amp</span></code> function amplitude or scaling factor.</p>
<p><code class="docutils literal notranslate"><span class="pre">xvar</span></code> x values (energy values in a lineshape).</p>
<p><code class="docutils literal notranslate"><span class="pre">ctr</span></code> center position.</p>
<p><code class="docutils literal notranslate"><span class="pre">sig</span></code> standard deviation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.gradn">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">gradn</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">array</span></em>, <em class="sig-param"><span class="n">axes</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.gradn" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate nth-order gradients of the array along different directions.</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>array: numpy array</dt><dd><p>N-dimensional matrix for calculating the gradient.</p>
</dd>
<dt>axes: int/list/tuple/1D array</dt><dd><p>A sequence of axes (from first to last) to calculate the gradient.
When input a single integer, the gradient is calculated along that particular axis.
For example, the 4th-order mixed gradient d4f/(dxdydxdy) requires the sequence (1, 0, 1, 0).</p>
</dd>
<dt><a href="#id47"><span class="problematic" id="id48">**</span></a>kwds: keyword arguments</dt><dd><p>See <code class="docutils literal notranslate"><span class="pre">numpy.gradient()</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.image_interpolator">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">image_interpolator</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">image</span></em>, <em class="sig-param"><span class="n">iptype</span><span class="o">=</span><span class="default_value">'RGI'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.image_interpolator" title="Permalink to this definition">¶</a></dt>
<dd><p>Construction of an image interpolator.</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>image: 2D array</dt><dd><p>2D image for interpolation.</p>
</dd>
<dt>iptype: str | ‘RGI’</dt><dd><p>Type of the interpolator.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>interp: interpolator instance</dt><dd><p>Instance of an interpolator.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.interp_slice">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">interp_slice</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">pathr</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">pathc</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">path_coords</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">iptype</span><span class="o">=</span><span class="default_value">'RGI'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.interp_slice" title="Permalink to this definition">¶</a></dt>
<dd><p>Slicing 2D/3D data through interpolation.</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>data: 2D/3D array</dt><dd><p>Data array for slicing.</p>
</dd>
<dt>pathr, pathc: list/tuple/array, list/tuple/array</dt><dd><p>Row and column coordinates of the interpolated path.</p>
</dd>
<dt>path_coords: array</dt><dd><p>Cartesian coordinates of the interpolated path.</p>
</dd>
<dt>iptype: str | ‘RGI’</dt><dd><p>Type of interpolator.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.line_generator">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">line_generator</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span></em>, <em class="sig-param"><span class="n">B</span></em>, <em class="sig-param"><span class="n">npoints</span></em>, <em class="sig-param"><span class="n">endpoint</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">ret</span><span class="o">=</span><span class="default_value">'separated'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.line_generator" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate intermediate points in a line segment AB (A to B) given endpoints.</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>A, B: tuple/list, tuple/list</dt><dd><p>Pixel coordinates of the endpoints of the line segment.</p>
</dd>
<dt>npoints: numeric</dt><dd><p>Number of points in the line segment.</p>
</dd>
<dt>endpoint: bool | True</dt><dd><p>Option to include the endpoint (B) in the line coordinates.</p>
</dd>
<dt>ret: str | ‘separated’</dt><dd><p>Option to return line coordinates (‘separated’ or ‘joined’).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.peakdetect1d">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">peakdetect1d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y_axis</span></em>, <em class="sig-param"><span class="n">x_axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">lookahead</span><span class="o">=</span><span class="default_value">200</span></em>, <em class="sig-param"><span class="n">delta</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.peakdetect1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Function for detecting local maxima and minima in a signal.
Discovers peaks by searching for values which are surrounded by lower
or larger values for maxima and minima respectively</p>
<p>Converted from/based on a MATLAB script at:
<a class="reference external" href="http://billauer.co.il/peakdet.html">http://billauer.co.il/peakdet.html</a></p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>y_axis: list</dt><dd><p>A list containing the signal over which to find peaks</p>
</dd>
<dt>x_axis: list | None</dt><dd><p>A x-axis whose values correspond to the y_axis list and is used
in the return to specify the position of the peaks. If omitted an
index of the y_axis is used.</p>
</dd>
<dt>lookahead: int | 200</dt><dd><p>distance to look ahead from a peak candidate to determine if
it is the actual peak
‘(samples / period) / f’ where ‘4 &gt;= f &gt;= 1.25’ might be a good value</p>
</dd>
<dt>delta: numeric | 0</dt><dd><p>this specifies a minimum difference between a peak and
the following points, before a peak may be considered a peak. Useful
to hinder the function from picking up false peaks towards to end of
the signal. To work well delta should be set to delta &gt;= RMSnoise * 5.</p>
</dd>
</dl>
<p><strong>Returns</strong></p>
<dl class="simple">
<dt>max_peaks: list</dt><dd><p>positions of the positive peaks</p>
</dd>
<dt>min_peaks: list</dt><dd><p>positions of the negative peaks</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.peakdetect2d">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">peakdetect2d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">img</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'daofind'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.peakdetect2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Peak-like feature detection in a 2D image.</p>
<p><strong>Parameters</strong></p>
<dl>
<dt>img: 2D array</dt><dd><p>Image matrix.</p>
</dd>
<dt>method: str | ‘daofind’</dt><dd><p>Detection method (‘daofind’ or ‘maxlist’).</p>
</dd>
<dt><a href="#id49"><span class="problematic" id="id50">**</span></a>kwds: keyword arguments</dt><dd><p>Arguments passed to the specific methods chosen.</p>
<dl class="field-list simple">
<dt class="field-odd">daofind</dt>
<dd class="field-odd"><p>See <code class="docutils literal notranslate"><span class="pre">astropy.stats.sigma_clipped_stats()</span></code> and <code class="docutils literal notranslate"><span class="pre">photutils.detection.DAOStarFinder()</span></code>.</p>
</dd>
</dl>
<dl class="simple">
<dt>sigma: float | 5.0</dt><dd><p>Standard deviation of the clipping Gaussian.</p>
</dd>
<dt>fwhm: float | 3.0</dt><dd><p>FWHM of the convoluting Gaussian kernel.</p>
</dd>
<dt>threshfactor: float | 8</dt><dd><p>Intensity threshold for background-foreground separation (foreground is above threshold).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">maxlist</dt>
<dd class="field-odd"><p>See <code class="docutils literal notranslate"><span class="pre">skimage.feature.peak_local_max()</span></code>.</p>
</dd>
</dl>
<dl class="simple">
<dt>mindist: float | 10</dt><dd><p>Minimal distance between two local maxima.</p>
</dd>
<dt>numpeaks: int | 7</dt><dd><p>Maximum number of detected peaks.</p>
</dd>
</dl>
</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>pks: 2D array</dt><dd><p>Pixel coordinates of detected peaks, in (column, row) ordering.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.peaksearch">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">peaksearch</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">traces</span></em>, <em class="sig-param"><span class="n">tof</span></em>, <em class="sig-param"><span class="n">ranges</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'range-limited'</span></em>, <em class="sig-param"><span class="n">pkwindow</span><span class="o">=</span><span class="default_value">3</span></em>, <em class="sig-param"><span class="n">plot</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.peaksearch" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect a list of peaks in the corresponding regions of multiple EDCs</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>traces: 2D array</dt><dd><p>Collection of EDCs.</p>
</dd>
<dt>tof: 1D array</dt><dd><p>Time-of-flight values.</p>
</dd>
<dt>ranges: list of tuples/lists | None</dt><dd><p>List of ranges for peak detection in the format
[(LowerBound1, UpperBound1), (LowerBound2, UpperBound2), ….].</p>
</dd>
<dt>method: str | ‘range-limited’</dt><dd><p>Method for peak-finding (‘range-limited’ and ‘alignment’).</p>
</dd>
<dt>pkwindow: int | 3</dt><dd><p>Window width of a peak(amounts to lookahead in <code class="docutils literal notranslate"><span class="pre">mpes.analysis.peakdetect1d</span></code>).</p>
</dd>
<dt>plot: bool | False</dt><dd><p>Specify whether to display a custom plot of the peak search results.</p>
</dd>
</dl>
<p><strong>Returns</strong></p>
<dl class="simple">
<dt>pkmaxs: 1D array</dt><dd><p>Collection of peak positions.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.perspectiveWarping">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">perspectiveWarping</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">img</span></em>, <em class="sig-param"><span class="n">landmarks</span></em>, <em class="sig-param"><span class="n">targs</span></em>, <em class="sig-param"><span class="n">ret</span><span class="o">=</span><span class="default_value">'image'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.perspectiveWarping" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform image warping based on a generic affine transform (homography).</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>img: 2D array</dt><dd><p>Input image (distorted).</p>
</dd>
<dt>landmarks: list/array</dt><dd><p>List of pixel positions of the reference points.</p>
</dd>
<dt>targs: list/array</dt><dd><p>List of pixel positions of the target points.</p>
</dd>
</dl>
<p><strong>Returns</strong></p>
<dl class="simple">
<dt>imgaw: 2D array</dt><dd><p>Image after affine warping.</p>
</dd>
<dt>maw: 2D array</dt><dd><p>Homography matrix for the tranform.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.points2path">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">points2path</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pointsr</span></em>, <em class="sig-param"><span class="n">pointsc</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'analog'</span></em>, <em class="sig-param"><span class="n">npoints</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ret</span><span class="o">=</span><span class="default_value">'separated'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.points2path" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate ordered pixel cooridnates along a path defined by specific intermediate points.
The approach constructs the path using a set of line segments bridging the specified points,
therefore it is also able to trace the sequence indices of these special points.</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>pointsr, pointsc: list/tuple/array</dt><dd><p>The row and column pixel coordinates of the special points along the sampling path.</p>
</dd>
<dt>method: str | ‘analog’</dt><dd><p>Method of sampling.</p>
</dd>
<dt>npoints: list/tuple | None</dt><dd><p>Number of points along each segment.</p>
</dd>
<dt>ret: str | ‘separated’</dt><dd><p>Specify if return combined (‘combined’) or separated (‘separated’) row and column coordinates.</p>
</dd>
</dl>
<p><strong>Returns</strong></p>
<dl class="simple">
<dt>polyr, polyc: 1D array</dt><dd><p>Pixel coordinates along the path traced out sequentially.</p>
</dd>
<dt>pid: 1D array</dt><dd><p>Pointwise indices of the special lpoints.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.rangeConvert">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">rangeConvert</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">xrng</span></em>, <em class="sig-param"><span class="n">pathcorr</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.rangeConvert" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert value range using a pairwise path correspondence (e.g. obtained
from time warping techniques).</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>x: 1D array</dt><dd><p>Values of the x axis (e.g. time-of-flight values).</p>
</dd>
<dt>xrng: list/tuple</dt><dd><p>Boundary value range on the x axis.</p>
</dd>
<dt>pathcorr: list/tuple</dt><dd><p>Path correspondence between two 1D arrays in the following form,
[(id_1_trace_1, id_1_trace_2), (id_2_trace_1, id_2_trace_2), …]</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>xrange_trans: tuple</dt><dd><p>Transformed range according to the path correspondence.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.rectmask">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">rectmask</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">img</span></em>, <em class="sig-param"><span class="n">rcent</span></em>, <em class="sig-param"><span class="n">ccent</span></em>, <em class="sig-param"><span class="n">shift</span></em>, <em class="sig-param"><span class="n">direction</span><span class="o">=</span><span class="default_value">'row'</span></em>, <em class="sig-param"><span class="n">sign</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">ret</span><span class="o">=</span><span class="default_value">'mask'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.rectmask" title="Permalink to this definition">¶</a></dt>
<dd><p>Use a rectangular binary mask to cover an image.</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>img: 2D array</dt><dd><p>Input image to be masked</p>
</dd>
<dt>rcent: float</dt><dd><p>Row center position</p>
</dd>
<dt>ccent: float</dt><dd><p>Column center position</p>
</dd>
<dt>shift: int/list of int</dt><dd><p>Pixel shifts</p>
</dd>
<dt>direction: str | ‘row’</dt><dd><p>Direction to apply the shift to, ‘row’ or ‘column’ indicates row-wise
or column-wise shift for generating the rectangular mask</p>
</dd>
<dt>sign: int/str | 1</dt><dd><p>Value of the masked region (0, 1, ‘nan’ or ‘xnan’).
‘xnan’ means the masked region is 1 and the other region nan.</p>
</dd>
<dt>ret: str | ‘mask’</dt><dd><p>Return type (‘mask’, ‘masked_image’)</p>
</dd>
</dl>
<p><a href="#id51"><span class="problematic" id="id52">**</span></a>kwds: keyword arguments</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>cmask or cmask*img: 2D array</dt><dd><p>Mask only or masked image</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.regionExpand">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">regionExpand</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mask</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.regionExpand" title="Permalink to this definition">¶</a></dt>
<dd><p>Expand the region of a binarized image around a line position</p>
<p><strong>Parameters</strong></p>
<dl>
<dt>mask: numeric binarized 2D array</dt><dd><p>the mask to be expanded</p>
</dd>
<dt><a href="#id53"><span class="problematic" id="id54">**</span></a>kwds: keyword arguments</dt><dd><table class="docutils align-default">
<colgroup>
<col style="width: 21%" />
<col style="width: 16%" />
<col style="width: 62%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>keyword</p></th>
<th class="head"><p>data type</p></th>
<th class="head"><p>meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>method</p></td>
<td><p>str</p></td>
<td><p>method of choice (‘offset’, ‘growth’)</p></td>
</tr>
<tr class="row-odd"><td><p>value</p></td>
<td><p>numeric</p></td>
<td><p>value to be assigned to the masked</p></td>
</tr>
<tr class="row-even"><td><p>linecoords</p></td>
<td><p>2D array</p></td>
<td><p>contains x and y positions of the line</p></td>
</tr>
<tr class="row-odd"><td><p>axoffsets</p></td>
<td><p>tuple/list</p></td>
<td><p>[downshift upshift] pixel number</p></td>
</tr>
<tr class="row-even"><td><p>clipbounds</p></td>
<td><p>tuple/list</p></td>
<td><p>bounds in the clipping direction</p></td>
</tr>
<tr class="row-odd"><td><p>selem</p></td>
<td><p>ndarray</p></td>
<td><p>structuring element</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>mask: numeric 2D array</dt><dd><p>modified mask (returns the original mask if insufficient arguments
are provided for the chosen method for region expansion)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.ridgeDetect">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">ridgeDetect</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mask</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'mask_mean_y'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.ridgeDetect" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect the band ridges using selected methods.</p>
<p><strong>Parameters</strong></p>
<dl>
<dt>mask: numeric 2D array</dt><dd><p>the 2D integer-valued mask with labeled bands</p>
</dd>
<dt>method: str</dt><dd><p>the method used for ridge detection
‘mask_mean_y’: mean mask position along y direction (default)
‘mask_mean_x’: mean mask position along x direction</p>
</dd>
<dt><a href="#id55"><span class="problematic" id="id56">**</span></a>kwds: keyword arguments</dt><dd><table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 26%" />
<col style="width: 54%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>keyword</p></th>
<th class="head"><p>data type</p></th>
<th class="head"><p>meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>x</p></td>
<td><p>int/float</p></td>
<td><p>x axis coordinates</p></td>
</tr>
<tr class="row-odd"><td><p>y</p></td>
<td><p>int/float</p></td>
<td><p>y axis coordinates</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>ridges: list of dataframes</dt><dd><p>the ridge coordinates</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.segment2d">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">segment2d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">img</span></em>, <em class="sig-param"><span class="n">nbands</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.segment2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Electronic band segmentation using local thresholding
and connected component labeling</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>img: 2D numeric array</dt><dd><p>the 2D matrix to segment</p>
</dd>
<dt>nbands: int</dt><dd><p>number of electronic bands</p>
</dd>
</dl>
<p><a href="#id57"><span class="problematic" id="id58">**</span></a>kwds: keyword arguments</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>imglabeled: 2D numeric array</dt><dd><p>labeled mask</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.shirley">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">shirley</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">1e-05</span></em>, <em class="sig-param"><span class="n">maxiter</span><span class="o">=</span><span class="default_value">20</span></em>, <em class="sig-param"><span class="n">explicit</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">warning</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.shirley" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the 1D best Shirley-Proctor-Sherwood background S for a dataset (x, y).
A. Proctor, P. M. A. Sherwood, Anal. Chem. 54 13 (1982).
The function is adapted from Kane O’Donnell’s routine
1. Finds the biggest peak
2. Use the minimum value on either side of this peak as the terminal points
of the Shirley background.
3. Iterate over the process within maximum allowed iteration (maxiter) to
reach the tolerance level (tol).</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>x: 1D numeric array</dt><dd><p>The photoelectron energy axis.</p>
</dd>
<dt>y: 1D numeric array</dt><dd><p>The photoemission intensity axis.</p>
</dd>
<dt>tol: float | 1e-5</dt><dd><p>The fitting tolerance.</p>
</dd>
<dt>maxiter: int | 20</dt><dd><p>The maximal iteration.</p>
</dd>
<dt>explicit: bool | False</dt><dd><p>Option for explicit display of iteration number.</p>
</dd>
<dt>warning: bool | False</dt><dd><p>Option to display of warnings during calculation.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>sbg: 1D numeric array</dt><dd><p>Calculated Shirley background.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.shirley2d">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">shirley2d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">1e-05</span></em>, <em class="sig-param"><span class="n">maxiter</span><span class="o">=</span><span class="default_value">20</span></em>, <em class="sig-param"><span class="n">explicit</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">warning</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.shirley2d" title="Permalink to this definition">¶</a></dt>
<dd><p>2D Shirley background removal</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>x: 1D numeric array</dt><dd><p>Photoemission energy axis.</p>
</dd>
<dt>y: 2D numeric array</dt><dd><p>Photoemission intensity matrix.</p>
</dd>
<dt>tol: float | 1e-5</dt><dd><p>The fitting tolerance.</p>
</dd>
<dt>maxiter: int | 20</dt><dd><p>The maximal iteration.</p>
</dd>
<dt>explicit: bool | False</dt><dd><p>Option for explicit display of iteration number.</p>
</dd>
<dt>warning: bool | False</dt><dd><p>Option to display of warnings during calculation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.vertexGenerator">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">vertexGenerator</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">center</span></em>, <em class="sig-param"><span class="n">fixedvertex</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">cvd</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">arot</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">nside</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">direction</span><span class="o">=</span><span class="default_value">- 1</span></em>, <em class="sig-param"><span class="n">scale</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">diagdir</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ret</span><span class="o">=</span><span class="default_value">'all'</span></em>, <em class="sig-param"><span class="n">rettype</span><span class="o">=</span><span class="default_value">'float32'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.vertexGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Generation of the vertices of symmetric polygons.</p>
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt>center: (int, int)</dt><dd><p>Pixel positions of the symmetry center (row pixel, column pixel).</p>
</dd>
<dt>fixedvertex: (int, int) | None</dt><dd><p>Pixel position of the fixed vertex (row pixel, column pixel).</p>
</dd>
<dt>cvd: numeric | None</dt><dd><p>Center-vertex distance.</p>
</dd>
<dt>arot: float | None</dt><dd><p>Spacing in angle of rotation.</p>
</dd>
<dt>nside: int | None</dt><dd><p>The total number of sides for the polygon.</p>
</dd>
<dt>direction: int | -1</dt><dd><p>Direction of angular rotation (1 = counterclockwise, -1 = clockwise)</p>
</dd>
<dt>scale: float | 1</dt><dd><p>Radial scaling factor.</p>
</dd>
<dt>diagdir: str | None</dt><dd><p>Diagonal direction of the polygon (‘x’ or ‘y’).</p>
</dd>
<dt>ret: str | ‘all’</dt><dd><p>Return type. Specify ‘all’ returns all vertices, specify ‘generated’
returns only the generated ones (without the fixedvertex in the argument).</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>vertices: 2D array</dt><dd><p>Collection of generated vertices.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="mpes.analysis.voigt">
<code class="sig-prename descclassname">mpes.analysis.</code><code class="sig-name descname">voigt</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">feval</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">vardict</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.voigt" title="Permalink to this definition">¶</a></dt>
<dd><p>1D Voigt lineshape model. Returns numerical values if <code class="docutils literal notranslate"><span class="pre">feval=True</span></code>.</p>
<p><strong>Parameters</strong></p>
<dl>
<dt>feval: bool | False</dt><dd><p>Option to evaluate function.</p>
</dd>
<dt>vardict: dict | None</dt><dd><p>Dictionary containing values for the variables named as follows (as dictionary keys).</p>
<p><code class="docutils literal notranslate"><span class="pre">amp</span></code> function amplitude or scaling factor.</p>
<p><code class="docutils literal notranslate"><span class="pre">xvar</span></code> x values (energy values in a lineshape).</p>
<p><code class="docutils literal notranslate"><span class="pre">ctr</span></code> center position.</p>
<p><code class="docutils literal notranslate"><span class="pre">sig</span></code> standard deviation of the Gaussian component.</p>
<p><code class="docutils literal notranslate"><span class="pre">gam</span></code> linewidth of the Lorentzian component.</p>
</dd>
</dl>
</dd></dl>

</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="bandstructure.html" class="btn btn-neutral float-right" title="Band-mapping data classes (mpes.bandstructure)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="file_io.html" class="btn btn-neutral" title="File I/O &amp; Processing (mpes.fprocessing)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017-2020, R. Patrick Xian, Laurenz Rettig.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.1.2',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="_static/language_data.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>
from dateutil.parser import parse

from gdshoplib.services.notion.base import BasePage
from gdshoplib.services.notion.block import Block
from gdshoplib.services.notion.notion import Notion


class Page(BasePage):
    def refresh(self):
        Notion(caching=True).get_page(self.id)
        self.initialize()

    def initialize(self):
        super(Page, self).initialize()
        self.properties = PageProperty(self.page)

    def blocks(self, filter=None):
        if not filter:
            for block in self.notion.get_blocks(self.id):
                yield Block(block["id"], notion=self.notion, parent=self)
            return

        for block in self.notion.get_blocks(self.id):
            for k, v in filter.items():
                block = Block(block["id"], notion=self.notion, parent=self)
                if str(block.__getattr__(k)).lower() == str(v).lower():
                    yield block

    def commit(self):
        # –ü—Ä–æ–∏—Ç–µ—Ä–∏—Ä–æ–≤–∞—Ç—å—Å—è –ø–æ –∏–∑–º–µ–Ω–µ–Ω–∏—è–º –∏ –≤—ã–ø–æ–ª–Ω–∏—Ç—å –≤ Notion
        ...

    def to_json(self):
        # –í–µ—Ä–Ω—É—Ç—å —Ç–æ–≤–∞—Ä –≤ json
        ...


class PageProperty:
    def __init__(self, page):
        self.page = page

    def __getitem__(self, key):
        return self.__dict__.get(key) or self.__search_content(key)

    def __getattr__(self, key):
        return self[key]

    def __search_content(self, key):
        for _, prop in self.page.get("properties", {}).items():
            for prop_field in self.__get_prop(key):
                if prop["id"] == prop_field["id"]:
                    data = self.properties_type_parse_map.get(prop["type"])(prop)
                    handler = prop_field.get("handler")

                    if handler and data:
                        return handler(data)
                    return data
        raise AttributeError

    def __get_prop(self, key):
        return self.properties_keys_map[key]

    def __str__(self) -> str:
        return f"{self.__class__}"

    def __repr__(self) -> str:
        return f"{self.__class__}"

    def relation_handler(self, page_id_in_list):
        _id = page_id_in_list[0]["id"]
        return Page(_id)

    def relation_list_handler(self, page_ids):
        result = []
        for _id in page_ids:
            result.append(Page(_id["id"]))
        return result

    def date_handler(self, date):
        if not date:
            return
        elif "start" in date:
            return parse(date["start"]).date()

        return parse(date).date()

    def files_field_handler(self, files):
        if not files:
            return None
        if len(files) == 1:
            return files[0]["file"]["url"]
        return [file["file"]["url"] for file in files]

    @property
    def properties_keys_map(self):
        return {
            "title": (dict(name="Name", id="title"),),
            "edited_by": (dict(name="Last edited by", id="~%7BrF"),),
            "work": (dict(name="–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å", id="bAcI"),),
            "created_time": (
                dict(name="Created time", id="v%5Dsj", handler=self.date_handler),
            ),
            "short_description": (dict(name="–ö–æ—Ä–æ—Ç–∫–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ", id="u_tU"),),
            "size": (
                dict(name="–†–∞–∑–º–µ—Ä", id="taW%3B"),
                dict(name="–†–∞–∑–º–µ—Ä", id="NUuD"),
            ),
            "notes_field": (dict(name="–ü—Ä–∏–º–µ—á–∞–Ω–∏—è", id="sXND"),),
            "quantity": (dict(name="–ö–æ–ª-–≤–æ", id="pXTy"),),
            "edited_time": (
                dict(name="Last edited time", id="mVEw", handler=self.date_handler),
            ),
            "collection": (dict(name="–ö–æ–ª–ª–µ–∫—Ü–∏—è", id="W%5BhI"),),
            "name": (dict(name="–ù–∞–∑–≤–∞–Ω–∏–µ –Ω–∞ —Ä—É—Å—Å–∫–æ–º", id="Tss%5D"),),
            "created_by": (dict(name="Created by", id="TbyK"),),
            "kit_field": (
                dict(
                    name="–ö–æ–º–ø–ª–µ–∫—Ç", id="QV%5D%5D", handler=self.relation_list_handler
                ),
            ),
            "tags_field": (dict(name="–¢–µ–≥–∏", id="MqdC"),),
            "status_description": (dict(name="–û–ø–∏—Å–∞–Ω–∏–µ", id="MUl%7C"),),
            "status_publication": (dict(name="–ü—É–±–ª–∏–∫–∞—Ü–∏—è", id="BeEA"),),
            "color": (dict(name="–¶–≤–µ—Ç", id="Jvku"),),
            "specifications_field": (
                dict(name="–ú–∞—Ç–µ—Ä–∏–∞–ª—ã / –•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏", id="COmf"),
            ),
            "price_neitral": (dict(name="–ë–µ–∑—É–±—ã—Ç–æ—á–Ω–æ—Å—Ç—å", id="VmWm"),),
            "price_now": (dict(name="–¢–µ–∫—É—â–∞—è –¶–µ–Ω–∞", id="Ddaz"),),
            "price_kit": (dict(name="–¶–µ–Ω–∞ –∫–æ–º–ø–ª–µ–∫—Ç–∞", id="Dwfs"),),
            "price_current_discount": (dict(name="–¢–µ–∫—É—â–∞—è –°–∫–∏–¥–∫–∞", id="syrp"),),
            "price_agent": (dict(name="–ê–≥–µ–Ω—Ç—Å–∫–∞—è –¶–µ–Ω–∞", id="vC%5E%3D"),),
            "price_agent_kit": (dict(name="–ê–≥–µ–Ω—Ç—Å–∫–∏–π –∫–æ–º–ø–ª–µ–∫—Ç", id="M%60HY"),),
            "price_gross": (dict(name="–°–µ–±–µ—Å—Ç–æ–∏–º–æ—Å—Ç—å", id="d%3DhO"),),
            "avito_id": (dict(name="", id="voQ%3E"),),
            "vk_id": (dict(name="", id="Ve%7Ca"),),
            "discount_from_date": (
                dict(name="–î–∞—Ç–∞ –ø–æ—Å—Ç–∞–≤–∫–∏", id="%60_a%3D", handler=self.date_handler),
            ),
            "badge_field": (
                dict(name="üéñÔ∏è –ë–µ–π–¥–∂–∏", id="%3CU_H", handler=self.relation_list_handler),
            ),
            "file": (dict(name="–§–∞–π–ª", id="uK%3CN", handler=self.files_field_handler),),
            "coordinates": (dict(name="–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã", id="XU%7C%3F"),),
            "transparency": (dict(name="–ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å", id="RHj%5B"),),
            "sku": (dict(name="–ù–∞—à SKU", id="BKOs"),),
            "sku_s": (dict(name="SKU –ø–æ—Å—Ç–∞–≤—â–∏–∫–∞", id="BHve"),),
            "price_eur": (dict(name="–¶–µ–Ω–∞ (eur)", id="AyqD"),),
            "platforms": (
                dict(name="–ü–ª–∞—Ç—Ñ–æ—Ä–º—ã", id="%40Q~A", handler=self.relation_list_handler),
            ),
            "brand": (
                dict(name="–ë—Ä–µ–Ω–¥", id="gk%40%3B", handler=self.relation_handler),
            ),
            "categories": (
                dict(name="–ö–∞—Ç–µ–≥–æ—Ä–∏–∏", id="%7CFzB", handler=self.relation_list_handler),
            ),
            "price_coefficient": (
                dict(name="–ö–æ—ç—Ñ–∏—Ü–µ–Ω—Ç –±—Ä–µ–Ω–¥–∞", id="HjFs"),
                dict(name="–ù–∞—Ü–µ–Ω–∫–∞", id="YsUp"),
                dict(name="–ù–∞—Ü–µ–Ω–∫–∞", id="lNgd"),
            ),
        }

    @property
    def properties_type_parse_map(self):
        return {
            "rich_text": lambda data: " ".join(
                [t.get("plain_text", "") for t in data["rich_text"]]
            )
            or "",
            "number": lambda data: data["number"] or 0,
            "title": lambda data: data["title"][0]["text"]["content"],
            "select": lambda data: data.get("select").get("name")
            if data.get("select")
            else None,
            "multi_select": lambda data: data,
            "status": lambda data: data["status"]["name"],
            "date": lambda data: data["date"],
            "formula": lambda data: data["formula"]["number"],
            "relation": lambda data: data["relation"],
            "rollup": lambda data: data,
            "people": lambda data: data,
            "files": lambda data: data["files"],
            "checkbox": lambda data: data["checkbox"],
            "url": lambda data: data["url"],
            "email": lambda data: data,
            "phone_number": lambda data: data,
            "created_time": lambda data: parse(data["created_time"]),
            "created_by": lambda data: str(data["created_by"]),
            "last_edited_time": lambda data: parse(data["last_edited_time"]),
            "last_edited_by": lambda data: str(data["last_edited_by"]),
            "image": lambda data: data["image"]["file"]["url"],
            "video": lambda data: data["video"]["file"]["url"],
        }

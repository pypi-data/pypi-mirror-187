schema {
    query: RootQueryType
    mutation: RootMutationType
}

"An entry in a list of historical limits on an account."
type AccountLimitHistoryResultNumber {
    "The date that the limit was in effect."
    date: String
    "The type of limit that was in effect."
    description: String
    "The numerical limit."
    limit: Int
}

"Result of asking for account limits containing both account and admin limits."
type AccountLimitResultNumber {
    "The account limits which can be edited but cannot exceed admin limits."
    accountLimits: AccountLimitsNumber
    "The admin limits which are imposed by the system"
    adminLimits: AdminLimitsNumber
}

"""

Limits imposed on the account by the user. There is an analogous admin limits object
that sets the limits imposed by the system. The user can only adjust these limits up
to the values allowed by the admin limits.
"""
type AccountLimitsNumber {
    "Account id that the AccountLimits apply to."
    accountId: rID
    """

    If a user has an hours per day limit set, this sets how long that user must wait after
    the limit has been exceeded. Note that this is required by gaming regulations but does
    not need to be used by customers.
    """
    coolOffPeriod: Int
    "The total amount that may be deposited daily."
    dailyDeposit: Int
    "An optional limit of the number of hours per day that a user can use the app."
    hoursPerDay: Int
    "The total amount that may be deposited for the life of the account.."
    lifetimeDeposit: Int
    "The loss limit value for the last 24 hours."
    lossLimit24Hours: Int
    "The loss limit value for the last month."
    lossLimitMonthly: Int
    "The loss limit value for the last week."
    lossLimitWeekly: Int
    "The maximum liability that may be incurred by any one order."
    maxOrderLiabilityPerOrder: Int
    "The total amount that may be deposited per month."
    monthlyDeposit: Int
    "The maximum liability that may be incurred by all outstanding orders."
    orderLiability: Int
    "The total amount that may be deposited weekly."
    weeklyDeposit: Int
}

"""

A summary of the statistics of a user's history in a particular market. Whenever a user
makes a trade, places and order or has a settlement this data is updated. All data in
this object are related to that single user and single market.
"""
type AccountMarketStat {
    "The ID of the account associated with this record."
    accountId: rID
    "The average premium of all open contracts."
    averageOpenPremium: Float
    "The number of contracts that have been settled."
    contractsSettled: Int
    "The start time of the event."
    eventStartTime: Int
    "The unique ID for this record."
    id: rID
    "The UNIX milliseconds timestamp when the record was created."
    insertedAt: Int
    "The ID of the market that this record is associated with."
    marketId: rID
    "The maximum potential fees including all actual fees paid."
    maxPotentialFee: Int
    "The maximum potential profit, including all actual profit."
    maxPotentialProfit: Int
    "The maximum outstanding risk on the position."
    maxRisk: Int
    "The amount of potential fee that is related to unsettled contracts."
    openPotentialFee: Int
    "The potential profit from the outstanding contracts."
    openPotentialProfit: Int
    "The amount of risk associated with outstanding contracts."
    openRisk: Int
    "The status of the event associated with this record."
    status: String
    "The title of the event associated with this record."
    title: String
    "The total fees that have been collected on the settlements."
    totalFees: Int
    "The total Profit or Loss on all settlements."
    totalSettlementPnl: Int
    "The UNIX milliseconds timestamp when the record was last updated."
    updatedAt: Int
}

"""

Limits on the account imposed by the system. The user's account limits can never be adjusted
to exceed these limits.
"""
type AdminLimitsNumber {
    """

    If a user has an hours per day limit set, this sets how long that user must wait after
    the limit has been exceeded. Note that this is required by gaming regulations but does
    not need to be used by customers.
    """
    coolOffPeriod: Int
    "The total amount that may be deposited daily."
    dailyDeposit: Int
    "An optional limit of the number of hours per day that a user can use the app."
    hoursPerDay: Int
    "The total amount that may be deposited for the life of the account.."
    lifetimeDeposit: Int
    "The loss limit value for the last 24 hours."
    lossLimit24Hours: Int
    "The loss limit value for the last month."
    lossLimitMonthly: Int
    "The loss limit value for the last week."
    lossLimitWeekly: Int
    "The maximum liability that may be incurred by any one order."
    maxOrderLiabilityPerOrder: Int
    "The total amount that may be deposited per month."
    monthlyDeposit: Int
    "The maximum liability that may be incurred by all outstanding orders."
    orderLiability: Int
    "The total amount that may be deposited daily."
    weeklyDeposit: Int
}

"The result of requesting to cancel a batch of orders. One of these is listed per order."
type BatchCancelOrdersResult {
    "The order id that was requested to be cancelled.."
    orderId: rID
    "The status of the order id after the attempted cancellation."
    status: String
}

"A data structure that describes the bid or offer for the market."
type BidOrOffer {
    "The price of the bid or offer."
    price: Int
    "The quantity of contracts of the bid or offer."
    quantity: Int
}

"The result of requesting to cancel a single order."
type CancelOrderResult {
    "The status of the order that was requested to be cancelled."
    status: String
}

type LicenseResponse {
    expiresAt: String
    license: String
}

"""

The result of a successful login or confirmation of a 2FA attempt. This object will contain
the information needed by the user when attempting to use authenticated endpoints. The
token returned needs to be put in an "Authorization" header with "Bearer {{TOKEN}}" as the
value where "{{TOKEN}}" should be replaced with the token returned by this API. This
object also contains the refresh token that is needed to refresh the token when it expires
without going through the login procedure.
"""
type LoginResult {
    "The ISO-8601 timestamp when the user last logged in for the current session."
    currentLoginAt: String
    "The IP address used by the currently logged in user."
    deviceId: String
    ipAddress: String
    "The ISO-8601 timestamp when the user last logged in."
    lastLoginAt: String
    "The number of limits on the account."
    limitsNumber: AccountLimitResultNumber
    "Whether or not the client should prompt the user for TNC acceptance."
    promptTncAcceptance: Boolean
    "Whether or not the client should prompt the user to supply a 2FA code."
    promptTwoFactorAuth: Boolean
    "The token used to refresh the token used for authenticated requests."
    refreshToken: String
    "The id of the user's current session."
    sessionId: String
    "The integer status of the request."
    status: Int
    "Id of the user's TNC acceptance record."
    tncId: String
    "The token to use for requests that requre authentication."
    token: String
    "The UUID of the user from the database."
    userId: rID
    "The current profile for the user."
    userProfile: UserProfile
    "The string version of the user status."
    userStatus: String
    "The unique user ID associated with the user with the external user service."
    userUid: String
}

"The result of logging out of the platform."
type LogoutResult {
    "The id of the device that was logged out."
    deviceId: String
    "Th address of the user when the user logged out."
    ipAddress: String
    "Message to display post-logout, if any."
    message: String
    "The integer status of the request."
    status: Int
}

"A filter that can be passed to market info queries."
type MarketFilter {
    "The category of market to include or null if not filtered."
    category: String
    "The grouping of the market within its section. This may be `nil` or and empty string."
    grouping: String
    "Whether this filter has been set manually or automatically."
    manual: Boolean
    "The section of market to include or null if not filtered."
    section: String
    "The subcategory of market to include or null if not filtered."
    subcategory: String
}

"Information about the Market Filter Tree"
type MarketFilterTree {
    """

    Filter tree as JSON

    "name" is the filter value at this level (presently category, sub-category, and section)
    "children" is a sorted array of the filters below the level

    {
    "children": [
    {
    "name": "MLB",
    "children": [
    {
    "name": "Games",
    "children": [
    {
    "name": "Today",
    "children": []
    },
    {
    "name": "Upcoming",
    "children": []
    }
    ]
    },
    {
    "name": "AL Divisions",
    "children": [
    {
    "name": "Central",
    "children": []
    },
    {
    "name": "East",
    "children": []
    },
    {
    "name": "West",
    "children": []
    }
    ]
    },
    ...
    }
    """
    filtersAsJson: String
}

"The information that describes a single market."
type MarketInfo {
    "Is the market archived or not."
    archived: Boolean
    "The available bids on the market."
    bids(
        "An optional integer, greater than zero, to limit the number of results."
        limit: PosInt,
        "An optional sort.  By default bids are sorted highest to lowest"
        sort: SortOrder = DESC
    ): [BidOrOffer]
    "The UTC time when the market was closed or cancelled."
    closedAt: String
    "The text to use in describing the competition, e.g. NBA."
    competition: String
    "The description of the market."
    description: String
    "The string that can be used for the detailed brief on the market's event."
    detailedEventBrief: String
    "The string that can be used for the brief on the market's event."
    eventBrief: String
    "The id of the event that the market is attached to."
    eventId: rID
    "The UTC start date and time of the event."
    eventStart: String
    "The status of the event that the market is attached to."
    eventStatus: String
    "The type of event associated with the market."
    eventType: String
    "The list of filters in which the market appears."
    filters: [MarketFilter]
    "The category in which the market appears: `Upcoming`, `Live` or `nil`."
    homeCategory: String
    "The time that the last probability was received by the server."
    lastProbabilityAt: DateTime
    "The price of the last executed trade."
    lastTradedPrice: Int
    "Is the probability manual or from odds provider."
    manualProbability: Boolean
    "The unique id of the market"
    marketId: rID
    "The max price for orders and settlements in this market."
    maxPrice: Int
    "The available offers on the market."
    offers(
        "An optional integer, greater than zero, to limit the number of results."
        limit: PosInt,
        "An optional sort.  By default offers are sorted highest to lowest"
        sort: SortOrder = DESC
    ): [BidOrOffer]
    "A JSON array describing the rules how the order's price should increment/decrement on the UI."
    orderPriceRules: [PriceRules]
    "The map of participants in the market."
    participants: [Participant]
    "The text to use in describing the position."
    position: String
    "The market price that the market is trading at."
    price: Float
    "The change in price over the last 24 hours."
    priceChange24h: Int
    "What is the probability for the market"
    probability: Float
    "The question that the market is asking."
    question: String
    "A list of the last 15 recent trades on the market."
    recentTrades: [RecentTrade]
    "The result of the market."
    result: String
    "The rules for this market."
    rules: String
    "DEPRECATED The specifier for the rules to properly determine the market."
    rulesSpecifier: String
    "The human readable short title for the market."
    shortTitle: String
    "The specifier for the rules to properly determine the market."
    specifier: String
    "The text to use in describing the sport, e.g. Basketball."
    sport: String
    "The status of the market."
    status: String
    "A unique symbol for this market."
    symbol: String
    "The ISO8601 formatted string of when the market info was created.  See `timestampInt`."
    timestamp: String
    "The UNIX microseconds timestamp of when this market info was created."
    timestampInt: Int
    "The human readable title for the market."
    title: String
    "The list of filters to use for organizing trades, settlements and related items."
    tradingFilters: [MarketFilter]
    "Trade volume this market has had in the last 24 hours"
    volume24h: Int
}

"Encapsulates an account's history of settlements."
type NetSettlementHistory {
    "The settlement objects."
    settlements: [Settlement]
    "The total count of settlements returned."
    totalCount: Int
}

"An order in the system."
type Order {
    "The action of the order which should be `buy` or `sell`."
    action: String
    "The average price of the filled contracts on the order."
    avgPrice: Price
    "The unique ID provided from the FIX client if this is a FIX order."
    clientOrderId: String
    "The amount of contracts on the order that have been filled."
    filled: Int
    "The percentage of the contracts on the order that have been filled."
    filledPercentage: Int
    "The unique ID of the order."
    id: rID
    "The unix microseconds timestamp of the time the order was placed."
    insertedAt: Int
    "The id of the market that the order was placed on."
    marketId: rID
    "The type of order which can be either `limit` or `market`."
    orderType: String
    "The price that was requested with the order, if the order was a limit order."
    price: Price
    "The quantity of the order."
    quantity: Int
    "The status of the order."
    status: String
    "The ISO-8601 timestamp of the time the order was placed."
    time: String
    "The total value of the order, the total premium of all trades."
    totalValue: Int
}

"The result of a user attempting to place an order."
type OrderResult {
    "The list of errors that occurred, if any."
    errors: [String]
    "The order that was placed if the request was successful."
    order: Order
}

"A return result from mutations that return order lists."
type OrdersWithCount {
    "The list or orders returned."
    orders: [Order]
    "The total count of orders in the list."
    totalCount: Int
}

"The information that describes a single participant."
type Participant {
    "The abbreviation of the participant."
    abbreviation: String
    "The name of the participant."
    name: String
    "The role of the participant in the event, e.g: 'home' or 'away'."
    role: String
}

"A rule that instructs the UI on the best way to increment and decrement the price."
type PriceRules {
    "The smallest price for the rule."
    from: Int
    "The amount ot increment when the user presses an increment button."
    inc: Int
    "The greatest price for the rule."
    to: Int
}

"A data structure that defines an anonymized recent trade."
type RecentTrade {
    "Whether the `buyer` or the `seller` took the liquidity."
    liquidityTaker: String
    "The price of the trade."
    price: Int
    "The number of contracts the trade executed for."
    quantity: Int
    "The ISO8601 formatted string of when the market info was created same as the `timestampInt`."
    timestamp: String
    "The UNIX microseconds timestamp of when this market info was created."
    timestampInt: Int
}

type RootMutationType {
    "Cancel of all open orders of an account."
    cancelAllOrders(geoLocation: GeoLocationCode): [BatchCancelOrdersResult]
    "Cancels an order."
    cancelOrder(
        geoLocation: GeoLocationCode,
        "The id of the order that the user wishes to cancel."
        orderId: rID!
    ): CancelOrderResult
    "Batch cancel of orders."
    cancelOrders(
        geoLocation: GeoLocationCode,
        "The list of the ids of the orders that the user wishes to cancel."
        orderIds: [rID]
    ): [BatchCancelOrdersResult]
    "User submitting the 2FA code in order to login."
    confirm2Fa(
        "The 2FA code that was sent to the user by email."
        code: String!,
        "The email of the user that the confirmation is being made for."
        email: EmailAddress!,
        "The id of the session to confirm 2FA for."
        sessionId: String!,
        "The timestamp of the confirmation."
        timestamp: Int
    ): LoginResult
    "Creates a new order."
    confirmOrder(
        geoLocation: GeoLocationCode,
        "The data structure holding the details for the order to be placed."
        userOrder: UserOrder!
    ): OrderResult
    """

    Login to the platform using the credentials. Please note that if the user has 2FA enabled
    the actual login will occur when the 2FA code is confirmed in another call to the API.
    """
    login(
        "The credentials to use to log into the system."
        credentials: LoginCredentials!
    ): LoginResult
    "Logout of the platform on a specific device, invalidating all tokens."
    logout(
        "The information on the device to log out."
        deviceInfo: DeviceInfo
    ): LogoutResult
    "Create a new authorization token from the user's refresh token."
    newToken(refreshToken: String!): LoginResult
    "Request that another 2FA code be sent when apparently the user didnt get the code."
    resend2Fa(
        "The user id to resend the code for. The system will find the email for the user."
        email: EmailAddress!,
        "The session id to resend the code for."
        sessionId: String!
    ): TwoFactorAuthResult
    """

    Request a new 2FA code providing the reason - i.e. updating user profile for example.

    The reasons are enums defined above.
    """
    send2Fa: TwoFactorAuthResult
    "Allows a user to update phone and address in their profile using JSON input."
    updateProfile(
        "The data to update in the user profile."
        input: UserProfileInputV2!
    ): UpdateUserProfileResult
    "Allows a user to update their profile with new information."
    updateUserProfile(
        "The data to update in the user profile."
        input: UserProfileInput!
    ): UpdateUserProfileResult
}

type RootQueryType {
    "History of account limits changes by the user."
    accountLimitsHistoryNumber: [AccountLimitHistoryResultNumber]
    "Account limits for a single account - values are returned as integer numbers"
    accountLimitsNumber: AccountLimitResultNumber
    "List of all account market stats for a given account"
    accountMarketStats(
        "Optional filter for returned Account Market Stats."
        filter: StatsFilter,
        "The pagination to use for the results."
        pagination: Pagination
    ): [AccountMarketStat]
    "Returns the Geo fencing license"
    geoFencingLicense: LicenseResponse
    "Returns a JSON string representation of the marketFilters (Name, [Children])."
    marketFilterTree: MarketFilterTree
    "Returns a list of the markets and filtered details"
    marketInfos(
        "Optional list of IDs of the marketInfos to return"
        input: MarketInfosInput
    ): [MarketInfo]
    "List of all settlement for a given market"
    marketSettlements(
        "The market id to restrict the settlements to."
        marketId: rID!,
        "The pagination to use for the results."
        pagination: Pagination
    ): [TransactionHistory]
    "List of all deposits and withdrawals for account"
    myDepositAndWithdrawalHistory(pagination: Pagination): [TransactionHistory]
    "List of all orders for a user"
    myOrderHistory(
        "The id of the market to restrict the orders returned to."
        marketId: rID,
        "The pagination to use for the results."
        pagination: Pagination,
        "The sorting to use for the results."
        sortBy: OrdersSortBy
    ): OrdersWithCount
    "History of all settlements"
    mySettlementsHistory(
        "Optional filter for returned settlements."
        filter: SettlementsFilter,
        "The pagination to use for the results."
        pagination: Pagination
    ): NetSettlementHistory
    "List of trades associated with provided order id"
    myTradesForOrder(
        "The id of the order to find the trades for."
        orderId: rID!
    ): [Trade]
    "List of the user's trades"
    myTradesHistory(
        "A filter for market ids to include."
        filter: MarketIdsFilter,
        "The id of the market to restrict the trades to."
        marketId: rID,
        "The pagination to use for the results."
        pagination: Pagination,
        "How to sort the results of the query."
        sortBy: TradesSortBy = {direction: DESC, name: TIME}
    ): TradesWithCount
    "Opening and closing Trades for given settlement_id"
    tradesForSettlement(
        "The id of the settlement to find the trades for."
        settlementId: rID!
    ): SettlementTrades
    "A user's profile"
    userProfile: UserProfile
}

"The settlement object which defines the result of a trade closure or exipration."
type Settlement {
    "The id of the account that the settlement is associated with."
    accountId: rID!
    "The price of the contracts when the position was closed."
    closingPrice: Price!
    "The id of the trade that closed this settlement, if any."
    closingTradeId: rID
    "The fee charged for the settlement."
    fee: Price!
    "The profit or loss associated with the position."
    grossPnl: Price!
    "The unique id for the settlement."
    id: rID!
    "The UNIX microseconds timestamp of when the settement was created."
    insertedAt: Int!
    "The ISO-8601 date time of when the settement was created."
    insertedAtIso: String!
    "The id of the market that the settlement is associated with."
    marketId: rID!
    "The price of the contracts when the position was opened."
    openingPrice: Price!
    "The id of the trade that opened this settlement."
    openingTradeId: rID!
    "(DEPRECATED) The profit or loss associated with the position."
    profitAndLoss: Price! @deprecated(reason: "Use gross_pnl instead.")
    "(DEPRECATED) The net profit or loss minus fees."
    profitMinusFee: Price! @deprecated(reason: "Use realized_pnl instead.")
    "The number of contracts that were settled."
    quantity: Int!
    "The net profit or loss minus fees."
    realizedPnl: Price!
    "The amount of premium that was settled by the trade."
    settledPremium: Price!
    "The amount of risk that was settled by the trade."
    settledRisk: Price!
    "(DEPRECATED) The ISO-8601 date time of when the settlement was created."
    time: String! @deprecated(reason: "renamed to inserted_at_iso")
    "The type of settlement."
    type: SettlementType!
}

"Opening and closing trade for settlement."
type SettlementTrades {
    "The closing trade for the settlement. May be empty for expired settlements."
    closingTrade: Trade
    "The opening trade for the settlement."
    openingTrade: Trade
}

"""

Defines Trade type which encapsulates the user's side of a trade between two accounts on
the system. Trades can be executed with actions of buy or sell relative to the user. The
trade will be settled by one ore more other trades either when the position is closed or
when it expires. Before the trade is completely settled the type tracks how many contracts
and premium remain unsettled.
"""
type Trade {
    "The action of the trade relative to the user."
    action: String
    "The number of contracts that were traded."
    filled: Int
    "The gross PNL as a result of the trade."
    grossPnl: Price
    "The unique id of the trade."
    id: rID!
    "The microseconds timestamp the trade was created."
    insertedAt: Int
    "The market that the trade is associated with."
    marketId: rID
    "DEPRECATED Max possible free on trade"
    maxPotentialFee: Int
    "The ID of the order that caused the trade."
    orderId: rID
    "The premium paid on the trade by the user."
    premium: Price
    "The price that the trade was executed at."
    price: Price
    "The number of unsettled contracts in the trade."
    remaining: Int
    "Premium as yet unsettled."
    remainingPremium: Int
    "The ISO-8601 Date time the trade was created."
    time: String
}

"Result type that returns a list of trades along with the count in the list."
type TradesWithCount {
    "The total count of trades in the list."
    totalCount: Int!
    "The list of the trades."
    trades: [Trade]!
}

"""

A single transaction encapsulating money moving from or to the wallet of the user.
Transactions are written when a settlement occurs, a fee is charged, a deposit is
made or a withdraw is made. It's important to know that all apparent changes to the wallet,
such as placing an order, merely reserve liability for the wallet rather than actually
move money in the system.
"""
type TransactionHistory {
    "The account id that is associtaed with the transaction."
    accountId: rID
    "The amount of a transaction which may be negative."
    amount: Int
    "A unique ID for the transaction."
    id: rID
    "The date and time that the transaction was recorderd."
    insertedAt: Int
    """

    The optional market id associated with the transaction. This field will only be set
    for transactions that are relative to a market.
    """
    marketId: rID
    """

    A optional payment method. This field will only be set for transaction that are relative to
    payments.
    """
    method: String
    "The type of the transaction."
    type: String
}

"The result of enabling or disabling two factor authentication."
type TwoFactorAuthResult {
    "The sessionId in which the 2fa code is stored."
    sessionId: String
    "The status of the request."
    status: String
}

"The result of the mutation to update the user's address."
type UpdateUserProfileResult {
    "A list of string errors."
    errors: [String]
    "The status of the request with the server."
    status: Int!
    "The user profile of the user as a result of the change."
    userProfile: UserProfile!
}

"The profile of a user including any limits."
type UserProfile {
    "The UUID of the account associated with this user."
    accountId: rID
    "The address1 part of the address of the user."
    address1: String
    "The address2 part of the address of the user."
    address2: String
    "The city of the user."
    city: String
    "The country of the address."
    country: String
    "The DOB of the user."
    dateOfBirth: String
    "The first name of the user."
    firstName: String!
    "The UUID of the user profile."
    id: rID!
    "The industry in which the user works"
    industry: String
    "The job title of the user."
    jobTitle: String
    "The last name of the user."
    lastName: String!
    "Opt-in for marketing emails, text messages"
    optInMarketing: Boolean
    "The phone number of the user."
    phoneNumber: String
    ssn: String
    "The state of the user."
    state: String
    "Whether the 2FA is enabled for this user."
    twoFactorAuth: Boolean
    "Whether the 2FA is enabled per device for this user."
    twoFactorAuthPerDevice: Boolean
    "The user name of the user."
    username: String!
    "The zip code of the user."
    zipCode: String
}

"Which type of date range filter to apply"
enum DateRangeType {
    ROLLING_WINDOW
}

"An enumeration of the available keys on a limit to change. Refer to AccountLimits type."
enum LimitKeys {
    COOL_OFF_PERIOD
    DAILY_DEPOSIT
    HOURS_PER_DAY
    LIFETIME_DEPOSIT
    LOSS_LIMIT24_HOURS
    LOSS_LIMIT_MONTHLY
    LOSS_LIMIT_WEEKLY
    MAX_ORDER_LIABILITY_PER_ORDER
    MONTHLY_DEPOSIT
    ORDER_LIABILITY
    WEEKLY_DEPOSIT
}

"Filter options for limiting market_infos."
enum MarketFilterEnum {
    """

    Return active markets (default).

    A market is 'active' if it's 'pre_open', 'open', 'suspended' or
    ('close' or 'cancelled' but not yet archived)
    """
    ACTIVE
    """

    Return markets whose homeCategory is "Live" or "Upcoming"
    If there are any 'Live' markets (regardless of the number), no 'upcoming' are returned.
    "Upcoming" markets are only those that have status "open"
    If there are neither "Live" nor "Upcoming" markets, an empty list will be returned.

    Limited to a maximum of 10 records.  The 'limit' parameter can further constrain the results.
    """
    LIVE_AND_UPCOMING
}

"Different types of filters."
enum MarketFilterGroupEnum {
    "A market's organizational filters"
    BASIC
    "A market's trade filters"
    TRADE
}

"Possible actions that can be used in orders."
enum OrderAction {
    "An order to buy contracts."
    BUY
    "An order to sell contracts."
    SELL
}

"Possible actions that can be used in orders."
enum OrderType {
    """

    A limit order which defines a floor (for sell) or ceiling (for buy) price. The system
    will try to buy or sell shares at the best price possible until it hits the floor or
    ceiling limit price. Remaining unfilled amounts stay in the order book and could be
    filled at any time later by arriving orders.
    """
    LIMIT
    """

    A market order which doesnt constrain the price. Market orders buy or sell shares at the
    best possible price until they are filled or no more quantity is available. If a market
    order cannot be completely filled the unfilled quantity is cancelled.
    """
    MARKET
}

"Possible fields that a list of orders can be sorted by."
enum OrdersSortByField {
    "The percentage of the contracts requested in the order that have been filled."
    FILLED_PERCENTAGE
    "The quantity of the order."
    QUANTITY
    "The time that the order was placed."
    TIME
}

"Which increment to apply to the rolling window value"
enum RollingWindowIncrement {
    DAYS
    HOURS
    MINUTES
    MONTHS
    SECONDS
}

"An enumeration of possible settlement types in the system."
enum SettlementType {
    "The long position contracts were closed when it was long through a sell order."
    CLOSED_LONG
    "The short position contracts were closed when it was long through a buy order."
    CLOSED_SHORT
    "The contracts expired when the position was long."
    EXPIRED_LONG
    "The contracts expired when the position was short."
    EXPIRED_SHORT
}

"Defines possible values that can be used for sort order."
enum SortOrder {
    "Sort the values in ascending order."
    ASC
    "Sort the values in descending order."
    DESC
}

"Possible trades sorting attributes"
enum TradesSortByField {
    "The quantity of contracts in the trade."
    QUANTITY
    "The time that the order was placed."
    TIME
}

"""

The `DateTime` scalar type represents a date and time in the UTC
timezone. The DateTime appears in a JSON response as an ISO8601 formatted
string, including UTC timezone ("Z"). The parsed date and time string will
be converted to UTC if there is an offset.
"""
scalar DateTime

"An Email address"
scalar EmailAddress

"Geo Location code"
scalar GeoLocationCode

"""

The `NonNegInt` scalar type represents non-fractional whole numeric values greater
than or equal to 0
NonNegInt can represent values between `0` and `2^53 - 1` since it is
represented in JSON as double-precision floating point numbers specified
by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).
"""
scalar NonNegInt

"""

The `PosInt` scalar type represents non-fractional signed whole numeric values greater
than or equal to 1
PosInt can represent values between `1` and `2^53 - 1` since it is
represented in JSON as double-precision floating point numbers specified
by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).
"""
scalar PosInt

"Defines a scalar price."
scalar Price

"""

The `rID` scalar type represents a SportsX unique identifier, often used to
re-fetch an object or as key for a cache. The xID type appears in a JSON
response as a String; however, it is not intended to be human-readable.
When expected as an input type, any UUID formatted string will be accepted as an rID.
"""
scalar rID

"Specifies a date range to constrain the result set to.  At least one must be provided"
input DateRangeFilter {
    rollingWindow: RollingWindow
    type: DateRangeType!
}

"Contains information on a device registered in the system."
input DeviceInfo {
    "The unique id of the device from the device itself."
    deviceId: String
}

"Credentials used to login to the system."
input LoginCredentials {
    "The information about the device that the user is logging in on."
    deviceInfo: DeviceInfo
    "The email of the user."
    email: EmailAddress!
    "The password for the given email username."
    password: String!
}

"Parameters for selecting markets based on filter tree"
input MarketFilterType {
    "Which type of filter to query on"
    group: MarketFilterGroupEnum!
    "A path (list of node names) to a leaf in the market filter tree to set of markets"
    path: [String!]!
}

"Filter for sending market ids in a query for trade history."
input MarketIdsFilter {
    "A list of market ids to return trades for."
    marketIds: [rID]
}

"Query parameters for the `marketInfos` query"
input MarketInfosInput {
    "The type of filter that should be applied"
    filterBy: MarketFilterEnum
    "Number of records to constrain the return.  'nil' and '0' will not limit results"
    limit: NonNegInt
    "The specification of markets to fetch by filter name"
    marketFilter: MarketFilterType
    "A list of market ids to return settlements for. If specified, 'limit' is ignored."
    marketIds: [rID!]
}

"A sort order that can be passed to a query requesting a list of orders."
input OrdersSortBy {
    "The direction, `asc` or `desc` for the sort."
    direction: SortOrder = DESC
    "The name of the field to sort by."
    name: OrdersSortByField = TIME
}

"Data structure for pagination."
input Pagination {
    "The limit of values per page.  Integer value greater than 0."
    limit: PosInt!
    "The page of result where each page has `limit` values.  Integer >= 0"
    page: NonNegInt!
}

"A rolling window date range filter.  A rolling window from now into the past.  For instance the last 24 hours"
input RollingWindow {
    increment: RollingWindowIncrement!
    value: PosInt!
}

"Filters used in returning settlements."
input SettlementsFilter {
    "A list of market ids to return settlements for."
    marketIds: [rID!]
    settledOn: DateRangeFilter
    "Restrict settlements to given type(s)"
    settlementType: [SettlementType!] = [CLOSED_LONG, CLOSED_SHORT, EXPIRED_LONG, EXPIRED_SHORT]
}

"stats filter accepts list of market_ids and exclude_zero_settlements flag to filter stats result."
input StatsFilter {
    """

    A flag to determine if stats with 0 settlements should be allowed.
    if flag is true stats with 0 settlements is not allowed in response.
    if flag is false stats with 0 settlements is allowed in response.
    """
    excludeZeroSettlements: Boolean
    "A list of market ids to return stats for."
    marketIds: [rID]
}

"Trade's sorting attribute"
input TradesSortBy {
    "The direction to sort, either `asc` or `desc`"
    direction: SortOrder = DESC
    "The name of the attribute to sort on, default is `time`."
    name: TradesSortByField = TIME
}

"Encapsulates information needed to place an order a market."
input UserOrder {
    "The action of the order."
    action: OrderAction!
    "The ID of the market to place the order on."
    marketId: rID!
    "The type of order to place."
    orderType: OrderType!
    "The limit price for an order, which will be ignored for order_type `market`."
    price: Price
    "The quantity of the order in number of contracts."
    quantity: Int!
}

"Input to the mutation to change a user's profile."
input UserProfileInput {
    "The first line of the user's legal address."
    address1: String!
    "The second line of the user's legal address."
    address2: String
    "The city of the user's legal address."
    city: String!
    "The country of the address."
    country: String
    "The industry in which the user works"
    industry: String
    "The job title of the user."
    jobTitle: String
    "Opt-in for marketing emails, text messages"
    optInMarketing: Boolean
    "The phone number for the user."
    phoneNumber: String!
    "The state of the user's legal address."
    state: String!
    "The zip code of the user's legal address."
    zipCode: String!
}

input UserProfileInputV2 {
    "The data for user profile update."
    data: String!
}

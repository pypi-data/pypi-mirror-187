{"version":3,"file":"lib_index_js.8e45cbd5afbccccbdcb9.js","mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AAC4D;AACK;AACd;AACG;AAC4B;AACA;AAClF;AACA;AACA;AACA,eAAe,6DAAY;AAC3B,eAAe,sEAAqB,EAAE,2EAAwB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,kCAAkC,8FAAM;AACxC,kCAAkC,8FAAM;AACxC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+DAAe;AAC1C;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA,iEAAe,OAAO,EAAC;;;;;;;;;;;;;;;;;;;;;;;ACnDvB;AACA;AACA;AAC+B;AACY;AACS;AACD;AAC5C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,qDAAM;AACnC,oCAAoC,8DAAe;AACnD;AACA;AACA,gBAAgB,kCAAkC;AAClD;AACA;AACA;AACA;AACA,0CAA0C,yGAA8B;AACxE,kBAAkB,SAAQ;AAC1B,SAAS;AACT;AACA;AACA;AACA,uBAAuB,6CAAI;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,8DAAe;AACvD;AACA,4CAA4C,0BAA0B;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,wEAAqB;AAC/E;AACA;AACA;AACA;;;;;;;;;;;;;;;AClJA,iEAAe,qBAAuB,yEAAyE;;;;;;;;;;;;;;ACA/G,iEAAe,qBAAuB,yEAAyE","sources":["webpack://@jupyterlite/xeus-nelson-kernel/./lib/index.js","webpack://@jupyterlite/xeus-nelson-kernel/./lib/web_worker_kernel.js","webpack://@jupyterlite/xeus-nelson-kernel/./style/logos/nelson-logo-32x32.png","webpack://@jupyterlite/xeus-nelson-kernel/./style/logos/nelson-logo-64x64.png"],"sourcesContent":["// Copyright (c) QuantStack\n// Copyright (c) JupyterLite Contributors\n// Distributed under the terms of the Modified BSD License.\nimport { IServiceWorkerManager } from '@jupyterlite/server';\nimport { IBroadcastChannelWrapper } from '@jupyterlite/contents';\nimport { IKernelSpecs } from '@jupyterlite/kernel';\nimport { WebWorkerKernel } from './web_worker_kernel';\nimport logo32 from '!!file-loader?context=.!../style/logos/nelson-logo-32x32.png';\nimport logo64 from '!!file-loader?context=.!../style/logos/nelson-logo-64x64.png';\nconst server_kernel = {\n    id: '@jupyterlite/xeus-nelson-kernel-extension:kernel',\n    autoStart: true,\n    requires: [IKernelSpecs],\n    optional: [IServiceWorkerManager, IBroadcastChannelWrapper],\n    activate: (app, kernelspecs, serviceWorker, broadcastChannel) => {\n        kernelspecs.register({\n            spec: {\n                name: 'Nelson',\n                display_name: 'Nelson',\n                language: 'nelson',\n                argv: [],\n                spec: {\n                    argv: [],\n                    env: {},\n                    display_name: 'Nelson',\n                    language: 'nelson',\n                    interrupt_mode: 'message',\n                    metadata: {}\n                },\n                resources: {\n                    'logo-32x32': logo32,\n                    'logo-64x64': logo64\n                }\n            },\n            create: async (options) => {\n                const mountDrive = !!((serviceWorker === null || serviceWorker === void 0 ? void 0 : serviceWorker.enabled) && (broadcastChannel === null || broadcastChannel === void 0 ? void 0 : broadcastChannel.enabled));\n                if (mountDrive) {\n                    console.info('xeus-nelson contents will be synced with Jupyter Contents');\n                }\n                else {\n                    console.warn('xeus-nelson contents will NOT be synced with Jupyter Contents');\n                }\n                return new WebWorkerKernel({\n                    ...options,\n                    mountDrive\n                });\n            }\n        });\n    }\n};\nconst plugins = [server_kernel];\nexport default plugins;\n","// Copyright (c) Thorsten Beier\n// Copyright (c) JupyterLite Contributors\n// Distributed under the terms of the Modified BSD License.\nimport { wrap } from 'comlink';\nimport { Signal } from '@lumino/signaling';\nimport { PromiseDelegate } from '@lumino/coreutils';\nimport { PageConfig } from '@jupyterlab/coreutils';\nexport class WebWorkerKernel {\n    /**\n     * Instantiate a new WebWorkerKernel\n     *\n     * @param options The instantiation options for a new WebWorkerKernel\n     */\n    constructor(options) {\n        this._isDisposed = false;\n        this._disposed = new Signal(this);\n        this._executeDelegate = new PromiseDelegate();\n        this._parentHeader = undefined;\n        this._parent = undefined;\n        const { id, name, sendMessage, location } = options;\n        this._id = id;\n        this._name = name;\n        this._location = location;\n        this._sendMessage = sendMessage;\n        this._worker = new Worker(new URL('./worker.js', import.meta.url), {\n            type: 'module'\n        });\n        this._worker.onmessage = e => {\n            this._processWorkerMessage(e.data);\n        };\n        this._remote = wrap(this._worker);\n        this.initFileSystem(options);\n    }\n    async handleMessage(msg) {\n        this._parent = msg;\n        this._parentHeader = msg.header;\n        await this._sendMessageToWorker(msg);\n    }\n    async _sendMessageToWorker(msg) {\n        // TODO Remove this??\n        if (msg.header.msg_type !== 'input_reply') {\n            this._executeDelegate = new PromiseDelegate();\n        }\n        await this._remote.processMessage({ msg, parent: this.parent });\n        if (msg.header.msg_type !== 'input_reply') {\n            return await this._executeDelegate.promise;\n        }\n    }\n    /**\n     * Get the last parent header\n     */\n    get parentHeader() {\n        return this._parentHeader;\n    }\n    /**\n     * Get the last parent message (mimick ipykernel's get_parent)\n     */\n    get parent() {\n        return this._parent;\n    }\n    /**\n     * Get the kernel location\n     */\n    get location() {\n        return this._location;\n    }\n    /**\n     * Process a message coming from the pyodide web worker.\n     *\n     * @param msg The worker message to process.\n     */\n    _processWorkerMessage(msg) {\n        var _a, _b, _c, _d;\n        if (!msg.header) {\n            return;\n        }\n        msg.header.session = (_b = (_a = this._parentHeader) === null || _a === void 0 ? void 0 : _a.session) !== null && _b !== void 0 ? _b : '';\n        msg.session = (_d = (_c = this._parentHeader) === null || _c === void 0 ? void 0 : _c.session) !== null && _d !== void 0 ? _d : '';\n        this._sendMessage(msg);\n        // resolve promise\n        if (msg.header.msg_type === 'status' &&\n            msg.content.execution_state === 'idle') {\n            this._executeDelegate.resolve();\n        }\n    }\n    /**\n     * A promise that is fulfilled when the kernel is ready.\n     */\n    get ready() {\n        return Promise.resolve();\n    }\n    /**\n     * Return whether the kernel is disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * A signal emitted when the kernel is disposed.\n     */\n    get disposed() {\n        return this._disposed;\n    }\n    /**\n     * Dispose the kernel.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._worker.terminate();\n        this._worker = null;\n        this._remote = null;\n        this._isDisposed = true;\n        this._disposed.emit(void 0);\n    }\n    /**\n     * Get the kernel id\n     */\n    get id() {\n        return this._id;\n    }\n    /**\n     * Get the name of the kernel\n     */\n    get name() {\n        return this._name;\n    }\n    async initFileSystem(options) {\n        let driveName;\n        let localPath;\n        if (options.location.includes(':')) {\n            const parts = options.location.split(':');\n            driveName = parts[0];\n            localPath = parts[1];\n        }\n        else {\n            driveName = '';\n            localPath = options.location;\n        }\n        await this._remote.ready();\n        if (options.mountDrive) {\n            await this._remote.mount(driveName, '/drive', PageConfig.getBaseUrl());\n            await this._remote.cd(localPath);\n        }\n    }\n}\n","export default __webpack_public_path__ + \"69da0ac9a09126e3c01831219b74572f3b76533e342c72f8afa9fd8f01dcc8e8.png\";","export default __webpack_public_path__ + \"553002d543a9199df1e32348f99812205fb446205bd319f902ff7f8a27525f28.png\";"],"names":[],"sourceRoot":""}